<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bloom filter implementation specific to Parquet, as described in the spec."><title>parquet::bloom_filter - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="parquet" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (a423f68a0 2026-02-13)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-f9617a14.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/apache/parquet-format/25f05e73d8cd7f5c83532ce51cb4f4de8ba5f2a2/logo/parquet-logos_1.svg"></head><body class="rustdoc mod"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module bloom_filter</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../parquet/index.html"><img src="https://raw.githubusercontent.com/apache/parquet-format/25f05e73d8cd7f5c83532ce51cb4f4de8ba5f2a2/logo/parquet-logos_1.svg" alt="logo"></a><h2><a href="../../parquet/index.html">parquet</a><span class="version">57.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module bloom_<wbr>filter</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#bloom-filter-size" title="Bloom Filter Size">Bloom Filter Size</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate parquet</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">parquet</a></div><h1>Module <span>bloom_<wbr>filter</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/parquet/bloom_filter/mod.rs.html#18-641">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Bloom filter implementation specific to Parquet, as described
in the <a href="https://github.com/apache/parquet-format/blob/master/BloomFilter.md">spec</a>.</p>
<h2 id="bloom-filter-size"><a class="doc-anchor" href="#bloom-filter-size">Â§</a>Bloom Filter Size</h2>
<p>Parquet uses the <a href="https://arxiv.org/pdf/2101.01719">Split Block Bloom Filter</a> (SBBF) as its bloom filter
implementation. For each column upon which bloom filters are enabled, the offset and length of an SBBF
is stored in  the metadata for each row group in the parquet file. The size of each filter is
initialized using a calculation based on the desired number of distinct values (NDV) and false
positive probability (FPP). The FPP for a SBBF can be approximated as<sup><a href="http://tfk.mit.edu/pdf/bloom.pdf">1</a></sup>:</p>
<div class="example-wrap"><pre class="language-text"><code>f = (1 - e^(-k * n / m))^k</code></pre></div>
<p>Where, <code>f</code> is the FPP, <code>k</code> the number of hash functions, <code>n</code> the NDV, and <code>m</code> the total number
of bits in the bloom filter. This can be re-arranged to determine the total number of bits
required to achieve a given FPP and NDV:</p>
<div class="example-wrap"><pre class="language-text"><code>m = -k * n / ln(1 - f^(1/k))</code></pre></div>
<p>SBBFs use eight hash functions to cleanly fit in SIMD lanes<sup><a href="https://arxiv.org/pdf/2101.01719">2</a></sup>, therefore
<code>k</code> is set to 8. The SBBF will spread those <code>m</code> bits accross a set of <code>b</code> blocks that
are each 256 bits, i.e., 32 bytes, in size. The number of blocks is chosen as:</p>
<div class="example-wrap"><pre class="language-text"><code>b = NP2(m/8) / 32</code></pre></div>
<p>Where, <code>NP2</code> denotes <em>the next power of two</em>, and <code>m</code> is divided by 8 to be represented as bytes.</p>
<p>Here is a table of calculated sizes for various FPP and NDV:</p>
<div><table><thead><tr><th>NDV</th><th>FPP</th><th>b</th><th>Size (KB)</th></tr></thead><tbody>
<tr><td>10,000</td><td>0.1</td><td>256</td><td>8</td></tr>
<tr><td>10,000</td><td>0.01</td><td>512</td><td>16</td></tr>
<tr><td>10,000</td><td>0.001</td><td>1,024</td><td>32</td></tr>
<tr><td>10,000</td><td>0.0001</td><td>1,024</td><td>32</td></tr>
<tr><td>100,000</td><td>0.1</td><td>4,096</td><td>128</td></tr>
<tr><td>100,000</td><td>0.01</td><td>4,096</td><td>128</td></tr>
<tr><td>100,000</td><td>0.001</td><td>8,192</td><td>256</td></tr>
<tr><td>100,000</td><td>0.0001</td><td>16,384</td><td>512</td></tr>
<tr><td>100,000</td><td>0.00001</td><td>16,384</td><td>512</td></tr>
<tr><td>1,000,000</td><td>0.1</td><td>32,768</td><td>1,024</td></tr>
<tr><td>1,000,000</td><td>0.01</td><td>65,536</td><td>2,048</td></tr>
<tr><td>1,000,000</td><td>0.001</td><td>65,536</td><td>2,048</td></tr>
<tr><td>1,000,000</td><td>0.0001</td><td>131,072</td><td>4,096</td></tr>
<tr><td>1,000,000</td><td>0.00001</td><td>131,072</td><td>4,096</td></tr>
<tr><td>1,000,000</td><td>0.000001</td><td>262,144</td><td>8,192</td></tr>
</tbody></table>
</div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Block.html" title="struct parquet::bloom_filter::Block">Block</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Each block is 256 bits, broken up into eight contiguous â€œwordsâ€, each consisting of 32 bits.
Each word is thought of as an array of bits; each bit is either â€œsetâ€ or â€œnot setâ€.</dd><dt><a class="struct" href="struct.BloomFilterHeader.html" title="struct parquet::bloom_filter::BloomFilterHeader">Bloom<wbr>Filter<wbr>Header</a></dt><dd>Bloom filter header is stored at beginning of Bloom filter data of each column
and followed by its bitset.</dd><dt><a class="struct" href="struct.Sbbf.html" title="struct parquet::bloom_filter::Sbbf">Sbbf</a></dt><dd>A split block Bloom filter.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.BITSET_MAX_LENGTH.html" title="constant parquet::bloom_filter::BITSET_MAX_LENGTH">BITSET_<wbr>MAX_<wbr>LENGTH</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.BITSET_MIN_LENGTH.html" title="constant parquet::bloom_filter::BITSET_MIN_LENGTH">BITSET_<wbr>MIN_<wbr>LENGTH</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.SALT.html" title="constant parquet::bloom_filter::SALT">SALT</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Salt as defined in the <a href="https://github.com/apache/parquet-format/blob/master/BloomFilter.md#technical-approach">spec</a>.</dd><dt><a class="constant" href="constant.SBBF_HEADER_SIZE_ESTIMATE.html" title="constant parquet::bloom_filter::SBBF_HEADER_SIZE_ESTIMATE">SBBF_<wbr>HEADER_<wbr>SIZE_<wbr>ESTIMATE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.SEED.html" title="constant parquet::bloom_filter::SEED">SEED</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.chunk_read_bloom_filter_header_and_offset.html" title="fn parquet::bloom_filter::chunk_read_bloom_filter_header_and_offset">chunk_<wbr>read_<wbr>bloom_<wbr>filter_<wbr>header_<wbr>and_<wbr>offset</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>given an initial offset, and a byte buffer, try to read out a bloom filter header and return
both the header and the offset after it (for bitset).</dd><dt><a class="fn" href="fn.hash_as_bytes.html" title="fn parquet::bloom_filter::hash_as_bytes">hash_<wbr>as_<wbr>bytes</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.num_of_bits_from_ndv_fpp.html" title="fn parquet::bloom_filter::num_of_bits_from_ndv_fpp">num_<wbr>of_<wbr>bits_<wbr>from_<wbr>ndv_<wbr>fpp</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.optimal_num_of_bytes.html" title="fn parquet::bloom_filter::optimal_num_of_bytes">optimal_<wbr>num_<wbr>of_<wbr>bytes</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="fn" href="fn.read_bloom_filter_header_and_length.html" title="fn parquet::bloom_filter::read_bloom_filter_header_and_length">read_<wbr>bloom_<wbr>filter_<wbr>header_<wbr>and_<wbr>length</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>given a [Bytes] buffer, try to read out a bloom filter header and return both the header and
length of the header.</dd><dt><a class="fn" href="fn.read_bloom_filter_header_and_length_from_bytes.html" title="fn parquet::bloom_filter::read_bloom_filter_header_and_length_from_bytes">read_<wbr>bloom_<wbr>filter_<wbr>header_<wbr>and_<wbr>length_<wbr>from_<wbr>bytes</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dd>Given a byte slice, try to read out a bloom filter header and return both the header and
length of the header.</dd></dl></section></div></main></body></html>