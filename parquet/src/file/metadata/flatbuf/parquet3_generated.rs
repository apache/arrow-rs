// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod parquet {

#[allow(unused_imports, dead_code)]
pub mod format_3 {


#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TYPE: [Type; 8] = [
  Type::BOOLEAN,
  Type::INT32,
  Type::INT64,
  Type::INT96,
  Type::FLOAT,
  Type::DOUBLE,
  Type::BYTE_ARRAY,
  Type::FIXED_LEN_BYTE_ARRAY,
];

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Type(pub i8);
#[allow(non_upper_case_globals)]
impl Type {
  pub const BOOLEAN: Self = Self(0);
  pub const INT32: Self = Self(1);
  pub const INT64: Self = Self(2);
  pub const INT96: Self = Self(3);
  pub const FLOAT: Self = Self(4);
  pub const DOUBLE: Self = Self(5);
  pub const BYTE_ARRAY: Self = Self(6);
  pub const FIXED_LEN_BYTE_ARRAY: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BOOLEAN,
    Self::INT32,
    Self::INT64,
    Self::INT96,
    Self::FLOAT,
    Self::DOUBLE,
    Self::BYTE_ARRAY,
    Self::FIXED_LEN_BYTE_ARRAY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BOOLEAN => Some("BOOLEAN"),
      Self::INT32 => Some("INT32"),
      Self::INT64 => Some("INT64"),
      Self::INT96 => Some("INT96"),
      Self::FLOAT => Some("FLOAT"),
      Self::DOUBLE => Some("DOUBLE"),
      Self::BYTE_ARRAY => Some("BYTE_ARRAY"),
      Self::FIXED_LEN_BYTE_ARRAY => Some("FIXED_LEN_BYTE_ARRAY"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Type {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Type {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Type {
    type Output = Type;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Type {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Type {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Type {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FIELD_REPETITION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FIELD_REPETITION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FIELD_REPETITION_TYPE: [FieldRepetitionType; 3] = [
  FieldRepetitionType::REQUIRED,
  FieldRepetitionType::OPTIONAL,
  FieldRepetitionType::REPEATED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FieldRepetitionType(pub i8);
#[allow(non_upper_case_globals)]
impl FieldRepetitionType {
  pub const REQUIRED: Self = Self(0);
  pub const OPTIONAL: Self = Self(1);
  pub const REPEATED: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REQUIRED,
    Self::OPTIONAL,
    Self::REPEATED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REQUIRED => Some("REQUIRED"),
      Self::OPTIONAL => Some("OPTIONAL"),
      Self::REPEATED => Some("REPEATED"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for FieldRepetitionType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for FieldRepetitionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for FieldRepetitionType {
    type Output = FieldRepetitionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for FieldRepetitionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for FieldRepetitionType {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for FieldRepetitionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENCODING: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENCODING: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENCODING: [Encoding; 8] = [
  Encoding::PLAIN,
  Encoding::PLAIN_DICTIONARY,
  Encoding::RLE,
  Encoding::DELTA_BINARY_PACKED,
  Encoding::DELTA_LENGTH_BYTE_ARRAY,
  Encoding::DELTA_BYTE_ARRAY,
  Encoding::RLE_DICTIONARY,
  Encoding::BYTE_STREAM_SPLIT,
];

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Encoding(pub i8);
#[allow(non_upper_case_globals)]
impl Encoding {
  pub const PLAIN: Self = Self(0);
  pub const PLAIN_DICTIONARY: Self = Self(2);
  pub const RLE: Self = Self(3);
  pub const DELTA_BINARY_PACKED: Self = Self(5);
  pub const DELTA_LENGTH_BYTE_ARRAY: Self = Self(6);
  pub const DELTA_BYTE_ARRAY: Self = Self(7);
  pub const RLE_DICTIONARY: Self = Self(8);
  pub const BYTE_STREAM_SPLIT: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PLAIN,
    Self::PLAIN_DICTIONARY,
    Self::RLE,
    Self::DELTA_BINARY_PACKED,
    Self::DELTA_LENGTH_BYTE_ARRAY,
    Self::DELTA_BYTE_ARRAY,
    Self::RLE_DICTIONARY,
    Self::BYTE_STREAM_SPLIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PLAIN => Some("PLAIN"),
      Self::PLAIN_DICTIONARY => Some("PLAIN_DICTIONARY"),
      Self::RLE => Some("RLE"),
      Self::DELTA_BINARY_PACKED => Some("DELTA_BINARY_PACKED"),
      Self::DELTA_LENGTH_BYTE_ARRAY => Some("DELTA_LENGTH_BYTE_ARRAY"),
      Self::DELTA_BYTE_ARRAY => Some("DELTA_BYTE_ARRAY"),
      Self::RLE_DICTIONARY => Some("RLE_DICTIONARY"),
      Self::BYTE_STREAM_SPLIT => Some("BYTE_STREAM_SPLIT"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Encoding {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Encoding {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Encoding {
    type Output = Encoding;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Encoding {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Encoding {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Encoding {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMPRESSION_CODEC: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMPRESSION_CODEC: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPRESSION_CODEC: [CompressionCodec; 7] = [
  CompressionCodec::UNCOMPRESSED,
  CompressionCodec::SNAPPY,
  CompressionCodec::GZIP,
  CompressionCodec::LZO,
  CompressionCodec::BROTLI,
  CompressionCodec::ZSTD,
  CompressionCodec::LZ4_RAW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CompressionCodec(pub i8);
#[allow(non_upper_case_globals)]
impl CompressionCodec {
  pub const UNCOMPRESSED: Self = Self(0);
  pub const SNAPPY: Self = Self(1);
  pub const GZIP: Self = Self(2);
  pub const LZO: Self = Self(3);
  pub const BROTLI: Self = Self(4);
  pub const ZSTD: Self = Self(6);
  pub const LZ4_RAW: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNCOMPRESSED,
    Self::SNAPPY,
    Self::GZIP,
    Self::LZO,
    Self::BROTLI,
    Self::ZSTD,
    Self::LZ4_RAW,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNCOMPRESSED => Some("UNCOMPRESSED"),
      Self::SNAPPY => Some("SNAPPY"),
      Self::GZIP => Some("GZIP"),
      Self::LZO => Some("LZO"),
      Self::BROTLI => Some("BROTLI"),
      Self::ZSTD => Some("ZSTD"),
      Self::LZ4_RAW => Some("LZ4_RAW"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for CompressionCodec {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for CompressionCodec {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for CompressionCodec {
    type Output = CompressionCodec;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for CompressionCodec {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for CompressionCodec {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for CompressionCodec {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TIME_UNIT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TIME_UNIT: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TIME_UNIT: [TimeUnit; 3] = [
  TimeUnit::MS,
  TimeUnit::US,
  TimeUnit::NS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TimeUnit(pub i8);
#[allow(non_upper_case_globals)]
impl TimeUnit {
  pub const MS: Self = Self(0);
  pub const US: Self = Self(1);
  pub const NS: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MS,
    Self::US,
    Self::NS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MS => Some("MS"),
      Self::US => Some("US"),
      Self::NS => Some("NS"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for TimeUnit {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for TimeUnit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for TimeUnit {
    type Output = TimeUnit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for TimeUnit {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for TimeUnit {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for TimeUnit {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EDGE_INTERPOLATION_ALGORITHM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EDGE_INTERPOLATION_ALGORITHM: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EDGE_INTERPOLATION_ALGORITHM: [EdgeInterpolationAlgorithm; 5] = [
  EdgeInterpolationAlgorithm::SPHERICAL,
  EdgeInterpolationAlgorithm::VINCENTY,
  EdgeInterpolationAlgorithm::THOMAS,
  EdgeInterpolationAlgorithm::ANDOYER,
  EdgeInterpolationAlgorithm::KARNEY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EdgeInterpolationAlgorithm(pub i8);
#[allow(non_upper_case_globals)]
impl EdgeInterpolationAlgorithm {
  pub const SPHERICAL: Self = Self(0);
  pub const VINCENTY: Self = Self(1);
  pub const THOMAS: Self = Self(2);
  pub const ANDOYER: Self = Self(3);
  pub const KARNEY: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPHERICAL,
    Self::VINCENTY,
    Self::THOMAS,
    Self::ANDOYER,
    Self::KARNEY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPHERICAL => Some("SPHERICAL"),
      Self::VINCENTY => Some("VINCENTY"),
      Self::THOMAS => Some("THOMAS"),
      Self::ANDOYER => Some("ANDOYER"),
      Self::KARNEY => Some("KARNEY"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for EdgeInterpolationAlgorithm {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for EdgeInterpolationAlgorithm {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for EdgeInterpolationAlgorithm {
    type Output = EdgeInterpolationAlgorithm;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for EdgeInterpolationAlgorithm {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for EdgeInterpolationAlgorithm {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for EdgeInterpolationAlgorithm {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LOGICAL_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LOGICAL_TYPE: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LOGICAL_TYPE: [LogicalType; 18] = [
  LogicalType::NONE,
  LogicalType::StringType,
  LogicalType::MapType,
  LogicalType::ListType,
  LogicalType::EnumType,
  LogicalType::DecimalType,
  LogicalType::DateType,
  LogicalType::TimeType,
  LogicalType::TimestampType,
  LogicalType::IntType,
  LogicalType::NullType,
  LogicalType::JsonType,
  LogicalType::BsonType,
  LogicalType::UUIDType,
  LogicalType::Float16Type,
  LogicalType::VariantType,
  LogicalType::GeometryType,
  LogicalType::GeographyType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LogicalType(pub u8);
#[allow(non_upper_case_globals)]
impl LogicalType {
  pub const NONE: Self = Self(0);
  pub const StringType: Self = Self(1);
  pub const MapType: Self = Self(2);
  pub const ListType: Self = Self(3);
  pub const EnumType: Self = Self(4);
  pub const DecimalType: Self = Self(5);
  pub const DateType: Self = Self(6);
  pub const TimeType: Self = Self(7);
  pub const TimestampType: Self = Self(8);
  pub const IntType: Self = Self(9);
  pub const NullType: Self = Self(10);
  pub const JsonType: Self = Self(11);
  pub const BsonType: Self = Self(12);
  pub const UUIDType: Self = Self(13);
  pub const Float16Type: Self = Self(14);
  pub const VariantType: Self = Self(15);
  pub const GeometryType: Self = Self(16);
  pub const GeographyType: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::StringType,
    Self::MapType,
    Self::ListType,
    Self::EnumType,
    Self::DecimalType,
    Self::DateType,
    Self::TimeType,
    Self::TimestampType,
    Self::IntType,
    Self::NullType,
    Self::JsonType,
    Self::BsonType,
    Self::UUIDType,
    Self::Float16Type,
    Self::VariantType,
    Self::GeometryType,
    Self::GeographyType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::StringType => Some("StringType"),
      Self::MapType => Some("MapType"),
      Self::ListType => Some("ListType"),
      Self::EnumType => Some("EnumType"),
      Self::DecimalType => Some("DecimalType"),
      Self::DateType => Some("DateType"),
      Self::TimeType => Some("TimeType"),
      Self::TimestampType => Some("TimestampType"),
      Self::IntType => Some("IntType"),
      Self::NullType => Some("NullType"),
      Self::JsonType => Some("JsonType"),
      Self::BsonType => Some("BsonType"),
      Self::UUIDType => Some("UUIDType"),
      Self::Float16Type => Some("Float16Type"),
      Self::VariantType => Some("VariantType"),
      Self::GeometryType => Some("GeometryType"),
      Self::GeographyType => Some("GeographyType"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for LogicalType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for LogicalType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for LogicalType {
    type Output = LogicalType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for LogicalType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for LogicalType {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for LogicalType {}
pub struct LogicalTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_ORDER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_ORDER: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_ORDER: [ColumnOrder; 2] = [
  ColumnOrder::NONE,
  ColumnOrder::TypeDefinedOrder,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ColumnOrder(pub u8);
#[allow(non_upper_case_globals)]
impl ColumnOrder {
  pub const NONE: Self = Self(0);
  pub const TypeDefinedOrder: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TypeDefinedOrder,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TypeDefinedOrder => Some("TypeDefinedOrder"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ColumnOrder {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ColumnOrder {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ColumnOrder {
    type Output = ColumnOrder;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ColumnOrder {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ColumnOrder {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ColumnOrder {}
pub struct ColumnOrderUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PAGE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PAGE_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAGE_TYPE: [PageType; 4] = [
  PageType::DATA_PAGE,
  PageType::INDEX_PAGE,
  PageType::DICTIONARY_PAGE,
  PageType::DATA_PAGE_V2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PageType(pub i8);
#[allow(non_upper_case_globals)]
impl PageType {
  pub const DATA_PAGE: Self = Self(0);
  pub const INDEX_PAGE: Self = Self(1);
  pub const DICTIONARY_PAGE: Self = Self(2);
  pub const DATA_PAGE_V2: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DATA_PAGE,
    Self::INDEX_PAGE,
    Self::DICTIONARY_PAGE,
    Self::DATA_PAGE_V2,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DATA_PAGE => Some("DATA_PAGE"),
      Self::INDEX_PAGE => Some("INDEX_PAGE"),
      Self::DICTIONARY_PAGE => Some("DICTIONARY_PAGE"),
      Self::DATA_PAGE_V2 => Some("DATA_PAGE_V2"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for PageType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for PageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for PageType {
    type Output = PageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for PageType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for PageType {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for PageType {}
pub enum EmptyOffset {}
#[derive(Copy, Clone, PartialEq)]

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
pub struct Empty<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Empty<'a> {
  type Inner = Empty<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Empty<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Empty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args EmptyArgs
  ) -> ::flatbuffers::WIPOffset<Empty<'bldr>> {
    let mut builder = EmptyBuilder::new(_fbb);
    builder.finish()
  }

}

impl ::flatbuffers::Verifiable for Empty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EmptyArgs {
}
impl<'a> Default for EmptyArgs {
  #[inline]
  fn default() -> Self {
    EmptyArgs {
    }
  }
}

pub struct EmptyBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> EmptyBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> EmptyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EmptyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Empty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Empty<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Empty");
      ds.finish()
  }
}
pub enum DecimalOptsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DecimalOpts<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for DecimalOpts<'a> {
  type Inner = DecimalOpts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> DecimalOpts<'a> {
  pub const VT_PRECISION: ::flatbuffers::VOffsetT = 4;
  pub const VT_SCALE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    DecimalOpts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DecimalOptsArgs
  ) -> ::flatbuffers::WIPOffset<DecimalOpts<'bldr>> {
    let mut builder = DecimalOptsBuilder::new(_fbb);
    builder.add_scale(args.scale);
    builder.add_precision(args.precision);
    builder.finish()
  }


  #[inline]
  pub fn precision(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DecimalOpts::VT_PRECISION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DecimalOpts::VT_SCALE, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for DecimalOpts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("precision", Self::VT_PRECISION, false)?
     .visit_field::<i32>("scale", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct DecimalOptsArgs {
    pub precision: i32,
    pub scale: i32,
}
impl<'a> Default for DecimalOptsArgs {
  #[inline]
  fn default() -> Self {
    DecimalOptsArgs {
      precision: 0,
      scale: 0,
    }
  }
}

pub struct DecimalOptsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DecimalOptsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_precision(&mut self, precision: i32) {
    self.fbb_.push_slot::<i32>(DecimalOpts::VT_PRECISION, precision, 0);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: i32) {
    self.fbb_.push_slot::<i32>(DecimalOpts::VT_SCALE, scale, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> DecimalOptsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DecimalOptsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<DecimalOpts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for DecimalOpts<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("DecimalOpts");
      ds.field("precision", &self.precision());
      ds.field("scale", &self.scale());
      ds.finish()
  }
}
pub enum TimeOptsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TimeOpts<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for TimeOpts<'a> {
  type Inner = TimeOpts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> TimeOpts<'a> {
  pub const VT_IS_ADJUSTED_TO_UTC: ::flatbuffers::VOffsetT = 4;
  pub const VT_UNIT: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    TimeOpts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeOptsArgs
  ) -> ::flatbuffers::WIPOffset<TimeOpts<'bldr>> {
    let mut builder = TimeOptsBuilder::new(_fbb);
    builder.add_unit(args.unit);
    builder.add_is_adjusted_to_utc(args.is_adjusted_to_utc);
    builder.finish()
  }


  #[inline]
  pub fn is_adjusted_to_utc(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TimeOpts::VT_IS_ADJUSTED_TO_UTC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn unit(&self) -> TimeUnit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TimeUnit>(TimeOpts::VT_UNIT, Some(TimeUnit::MS)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for TimeOpts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("is_adjusted_to_utc", Self::VT_IS_ADJUSTED_TO_UTC, false)?
     .visit_field::<TimeUnit>("unit", Self::VT_UNIT, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeOptsArgs {
    pub is_adjusted_to_utc: bool,
    pub unit: TimeUnit,
}
impl<'a> Default for TimeOptsArgs {
  #[inline]
  fn default() -> Self {
    TimeOptsArgs {
      is_adjusted_to_utc: false,
      unit: TimeUnit::MS,
    }
  }
}

pub struct TimeOptsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TimeOptsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_is_adjusted_to_utc(&mut self, is_adjusted_to_utc: bool) {
    self.fbb_.push_slot::<bool>(TimeOpts::VT_IS_ADJUSTED_TO_UTC, is_adjusted_to_utc, false);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: TimeUnit) {
    self.fbb_.push_slot::<TimeUnit>(TimeOpts::VT_UNIT, unit, TimeUnit::MS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TimeOptsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeOptsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<TimeOpts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for TimeOpts<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("TimeOpts");
      ds.field("is_adjusted_to_utc", &self.is_adjusted_to_utc());
      ds.field("unit", &self.unit());
      ds.finish()
  }
}
pub enum IntOptsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntOpts<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for IntOpts<'a> {
  type Inner = IntOpts<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> IntOpts<'a> {
  pub const VT_BIT_WIDTH: ::flatbuffers::VOffsetT = 4;
  pub const VT_IS_SIGNED: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    IntOpts { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntOptsArgs
  ) -> ::flatbuffers::WIPOffset<IntOpts<'bldr>> {
    let mut builder = IntOptsBuilder::new(_fbb);
    builder.add_is_signed(args.is_signed);
    builder.add_bit_width(args.bit_width);
    builder.finish()
  }


  #[inline]
  pub fn bit_width(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(IntOpts::VT_BIT_WIDTH, Some(8)).unwrap()}
  }
  #[inline]
  pub fn is_signed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(IntOpts::VT_IS_SIGNED, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for IntOpts<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i8>("bit_width", Self::VT_BIT_WIDTH, false)?
     .visit_field::<bool>("is_signed", Self::VT_IS_SIGNED, false)?
     .finish();
    Ok(())
  }
}
pub struct IntOptsArgs {
    pub bit_width: i8,
    pub is_signed: bool,
}
impl<'a> Default for IntOptsArgs {
  #[inline]
  fn default() -> Self {
    IntOptsArgs {
      bit_width: 8,
      is_signed: false,
    }
  }
}

pub struct IntOptsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> IntOptsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_bit_width(&mut self, bit_width: i8) {
    self.fbb_.push_slot::<i8>(IntOpts::VT_BIT_WIDTH, bit_width, 8);
  }
  #[inline]
  pub fn add_is_signed(&mut self, is_signed: bool) {
    self.fbb_.push_slot::<bool>(IntOpts::VT_IS_SIGNED, is_signed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> IntOptsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntOptsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<IntOpts<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for IntOpts<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("IntOpts");
      ds.field("bit_width", &self.bit_width());
      ds.field("is_signed", &self.is_signed());
      ds.finish()
  }
}
pub enum GeometryTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeometryType<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for GeometryType<'a> {
  type Inner = GeometryType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> GeometryType<'a> {
  pub const VT_CRS: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    GeometryType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GeometryTypeArgs<'args>
  ) -> ::flatbuffers::WIPOffset<GeometryType<'bldr>> {
    let mut builder = GeometryTypeBuilder::new(_fbb);
    if let Some(x) = args.crs { builder.add_crs(x); }
    builder.finish()
  }


  #[inline]
  pub fn crs(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(GeometryType::VT_CRS, None)}
  }
}

impl ::flatbuffers::Verifiable for GeometryType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("crs", Self::VT_CRS, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryTypeArgs<'a> {
    pub crs: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GeometryTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryTypeArgs {
      crs: None,
    }
  }
}

pub struct GeometryTypeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GeometryTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_crs(&mut self, crs: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(GeometryType::VT_CRS, crs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GeometryTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<GeometryType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for GeometryType<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("GeometryType");
      ds.field("crs", &self.crs());
      ds.finish()
  }
}
pub enum GeographyTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GeographyType<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for GeographyType<'a> {
  type Inner = GeographyType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> GeographyType<'a> {
  pub const VT_CRS: ::flatbuffers::VOffsetT = 4;
  pub const VT_ALGORITHM: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    GeographyType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GeographyTypeArgs<'args>
  ) -> ::flatbuffers::WIPOffset<GeographyType<'bldr>> {
    let mut builder = GeographyTypeBuilder::new(_fbb);
    if let Some(x) = args.crs { builder.add_crs(x); }
    builder.add_algorithm(args.algorithm);
    builder.finish()
  }


  #[inline]
  pub fn crs(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(GeographyType::VT_CRS, None)}
  }
  #[inline]
  pub fn algorithm(&self) -> EdgeInterpolationAlgorithm {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EdgeInterpolationAlgorithm>(GeographyType::VT_ALGORITHM, Some(EdgeInterpolationAlgorithm::SPHERICAL)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for GeographyType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("crs", Self::VT_CRS, false)?
     .visit_field::<EdgeInterpolationAlgorithm>("algorithm", Self::VT_ALGORITHM, false)?
     .finish();
    Ok(())
  }
}
pub struct GeographyTypeArgs<'a> {
    pub crs: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub algorithm: EdgeInterpolationAlgorithm,
}
impl<'a> Default for GeographyTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeographyTypeArgs {
      crs: None,
      algorithm: EdgeInterpolationAlgorithm::SPHERICAL,
    }
  }
}

pub struct GeographyTypeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GeographyTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_crs(&mut self, crs: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(GeographyType::VT_CRS, crs);
  }
  #[inline]
  pub fn add_algorithm(&mut self, algorithm: EdgeInterpolationAlgorithm) {
    self.fbb_.push_slot::<EdgeInterpolationAlgorithm>(GeographyType::VT_ALGORITHM, algorithm, EdgeInterpolationAlgorithm::SPHERICAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GeographyTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GeographyTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<GeographyType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for GeographyType<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("GeographyType");
      ds.field("crs", &self.crs());
      ds.field("algorithm", &self.algorithm());
      ds.finish()
  }
}
pub enum StatisticsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Statistics<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Statistics<'a> {
  type Inner = Statistics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Statistics<'a> {
  pub const VT_NULL_COUNT: ::flatbuffers::VOffsetT = 4;
  pub const VT_MIN_LO4: ::flatbuffers::VOffsetT = 6;
  pub const VT_MIN_LO8: ::flatbuffers::VOffsetT = 8;
  pub const VT_MIN_HI8: ::flatbuffers::VOffsetT = 10;
  pub const VT_MIN_LEN: ::flatbuffers::VOffsetT = 12;
  pub const VT_MAX_LO4: ::flatbuffers::VOffsetT = 14;
  pub const VT_MAX_LO8: ::flatbuffers::VOffsetT = 16;
  pub const VT_MAX_HI8: ::flatbuffers::VOffsetT = 18;
  pub const VT_MAX_LEN: ::flatbuffers::VOffsetT = 20;
  pub const VT_PREFIX: ::flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Statistics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StatisticsArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Statistics<'bldr>> {
    let mut builder = StatisticsBuilder::new(_fbb);
    builder.add_max_hi8(args.max_hi8);
    builder.add_max_lo8(args.max_lo8);
    builder.add_min_hi8(args.min_hi8);
    builder.add_min_lo8(args.min_lo8);
    if let Some(x) = args.prefix { builder.add_prefix(x); }
    builder.add_max_lo4(args.max_lo4);
    builder.add_min_lo4(args.min_lo4);
    if let Some(x) = args.null_count { builder.add_null_count(x); }
    if let Some(x) = args.max_len { builder.add_max_len(x); }
    if let Some(x) = args.min_len { builder.add_min_len(x); }
    builder.finish()
  }


  #[inline]
  pub fn null_count(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Statistics::VT_NULL_COUNT, None)}
  }
  #[inline]
  pub fn min_lo4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Statistics::VT_MIN_LO4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn min_lo8(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Statistics::VT_MIN_LO8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn min_hi8(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Statistics::VT_MIN_HI8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn min_len(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Statistics::VT_MIN_LEN, None)}
  }
  #[inline]
  pub fn max_lo4(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Statistics::VT_MAX_LO4, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_lo8(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Statistics::VT_MAX_LO8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_hi8(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Statistics::VT_MAX_HI8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_len(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Statistics::VT_MAX_LEN, None)}
  }
  #[inline]
  pub fn prefix(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Statistics::VT_PREFIX, None)}
  }
}

impl ::flatbuffers::Verifiable for Statistics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("null_count", Self::VT_NULL_COUNT, false)?
     .visit_field::<u32>("min_lo4", Self::VT_MIN_LO4, false)?
     .visit_field::<u64>("min_lo8", Self::VT_MIN_LO8, false)?
     .visit_field::<u64>("min_hi8", Self::VT_MIN_HI8, false)?
     .visit_field::<i8>("min_len", Self::VT_MIN_LEN, false)?
     .visit_field::<u32>("max_lo4", Self::VT_MAX_LO4, false)?
     .visit_field::<u64>("max_lo8", Self::VT_MAX_LO8, false)?
     .visit_field::<u64>("max_hi8", Self::VT_MAX_HI8, false)?
     .visit_field::<i8>("max_len", Self::VT_MAX_LEN, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("prefix", Self::VT_PREFIX, false)?
     .finish();
    Ok(())
  }
}
pub struct StatisticsArgs<'a> {
    pub null_count: Option<i32>,
    pub min_lo4: u32,
    pub min_lo8: u64,
    pub min_hi8: u64,
    pub min_len: Option<i8>,
    pub max_lo4: u32,
    pub max_lo8: u64,
    pub max_hi8: u64,
    pub max_len: Option<i8>,
    pub prefix: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StatisticsArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatisticsArgs {
      null_count: None,
      min_lo4: 0,
      min_lo8: 0,
      min_hi8: 0,
      min_len: None,
      max_lo4: 0,
      max_lo8: 0,
      max_hi8: 0,
      max_len: None,
      prefix: None,
    }
  }
}

pub struct StatisticsBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StatisticsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_null_count(&mut self, null_count: i32) {
    self.fbb_.push_slot_always::<i32>(Statistics::VT_NULL_COUNT, null_count);
  }
  #[inline]
  pub fn add_min_lo4(&mut self, min_lo4: u32) {
    self.fbb_.push_slot::<u32>(Statistics::VT_MIN_LO4, min_lo4, 0);
  }
  #[inline]
  pub fn add_min_lo8(&mut self, min_lo8: u64) {
    self.fbb_.push_slot::<u64>(Statistics::VT_MIN_LO8, min_lo8, 0);
  }
  #[inline]
  pub fn add_min_hi8(&mut self, min_hi8: u64) {
    self.fbb_.push_slot::<u64>(Statistics::VT_MIN_HI8, min_hi8, 0);
  }
  #[inline]
  pub fn add_min_len(&mut self, min_len: i8) {
    self.fbb_.push_slot_always::<i8>(Statistics::VT_MIN_LEN, min_len);
  }
  #[inline]
  pub fn add_max_lo4(&mut self, max_lo4: u32) {
    self.fbb_.push_slot::<u32>(Statistics::VT_MAX_LO4, max_lo4, 0);
  }
  #[inline]
  pub fn add_max_lo8(&mut self, max_lo8: u64) {
    self.fbb_.push_slot::<u64>(Statistics::VT_MAX_LO8, max_lo8, 0);
  }
  #[inline]
  pub fn add_max_hi8(&mut self, max_hi8: u64) {
    self.fbb_.push_slot::<u64>(Statistics::VT_MAX_HI8, max_hi8, 0);
  }
  #[inline]
  pub fn add_max_len(&mut self, max_len: i8) {
    self.fbb_.push_slot_always::<i8>(Statistics::VT_MAX_LEN, max_len);
  }
  #[inline]
  pub fn add_prefix(&mut self, prefix: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Statistics::VT_PREFIX, prefix);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> StatisticsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StatisticsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Statistics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Statistics<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Statistics");
      ds.field("null_count", &self.null_count());
      ds.field("min_lo4", &self.min_lo4());
      ds.field("min_lo8", &self.min_lo8());
      ds.field("min_hi8", &self.min_hi8());
      ds.field("min_len", &self.min_len());
      ds.field("max_lo4", &self.max_lo4());
      ds.field("max_lo8", &self.max_lo8());
      ds.field("max_hi8", &self.max_hi8());
      ds.field("max_len", &self.max_len());
      ds.field("prefix", &self.prefix());
      ds.finish()
  }
}
pub enum SchemaElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SchemaElement<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for SchemaElement<'a> {
  type Inner = SchemaElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SchemaElement<'a> {
  pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: ::flatbuffers::VOffsetT = 6;
  pub const VT_REPETITION_TYPE: ::flatbuffers::VOffsetT = 8;
  pub const VT_LOGICAL_TYPE_TYPE: ::flatbuffers::VOffsetT = 10;
  pub const VT_LOGICAL_TYPE: ::flatbuffers::VOffsetT = 12;
  pub const VT_TYPE_LENGTH: ::flatbuffers::VOffsetT = 14;
  pub const VT_NUM_CHILDREN: ::flatbuffers::VOffsetT = 16;
  pub const VT_FIELD_ID: ::flatbuffers::VOffsetT = 18;
  pub const VT_COLUMN_ORDER_TYPE: ::flatbuffers::VOffsetT = 20;
  pub const VT_COLUMN_ORDER: ::flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SchemaElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SchemaElementArgs<'args>
  ) -> ::flatbuffers::WIPOffset<SchemaElement<'bldr>> {
    let mut builder = SchemaElementBuilder::new(_fbb);
    if let Some(x) = args.column_order { builder.add_column_order(x); }
    if let Some(x) = args.field_id { builder.add_field_id(x); }
    builder.add_num_children(args.num_children);
    if let Some(x) = args.type_length { builder.add_type_length(x); }
    if let Some(x) = args.logical_type { builder.add_logical_type(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_column_order_type(args.column_order_type);
    builder.add_logical_type_type(args.logical_type_type);
    builder.add_repetition_type(args.repetition_type);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(SchemaElement::VT_NAME, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<Type> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Type>(SchemaElement::VT_TYPE_, None)}
  }
  #[inline]
  pub fn repetition_type(&self) -> FieldRepetitionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FieldRepetitionType>(SchemaElement::VT_REPETITION_TYPE, Some(FieldRepetitionType::REQUIRED)).unwrap()}
  }
  #[inline]
  pub fn logical_type_type(&self) -> LogicalType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LogicalType>(SchemaElement::VT_LOGICAL_TYPE_TYPE, Some(LogicalType::NONE)).unwrap()}
  }
  #[inline]
  pub fn logical_type(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(SchemaElement::VT_LOGICAL_TYPE, None)}
  }
  #[inline]
  pub fn type_length(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SchemaElement::VT_TYPE_LENGTH, None)}
  }
  #[inline]
  pub fn num_children(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SchemaElement::VT_NUM_CHILDREN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn field_id(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SchemaElement::VT_FIELD_ID, None)}
  }
  #[inline]
  pub fn column_order_type(&self) -> ColumnOrder {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ColumnOrder>(SchemaElement::VT_COLUMN_ORDER_TYPE, Some(ColumnOrder::NONE)).unwrap()}
  }
  #[inline]
  pub fn column_order(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(SchemaElement::VT_COLUMN_ORDER, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_string_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::StringType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_map_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::MapType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_list_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::ListType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_enum_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::EnumType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_decimal_type(&self) -> Option<DecimalOpts<'a>> {
    if self.logical_type_type() == LogicalType::DecimalType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DecimalOpts::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_date_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::DateType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_time_type(&self) -> Option<TimeOpts<'a>> {
    if self.logical_type_type() == LogicalType::TimeType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeOpts::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_timestamp_type(&self) -> Option<TimeOpts<'a>> {
    if self.logical_type_type() == LogicalType::TimestampType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeOpts::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_int_type(&self) -> Option<IntOpts<'a>> {
    if self.logical_type_type() == LogicalType::IntType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { IntOpts::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_null_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::NullType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_json_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::JsonType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_bson_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::BsonType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_uuidtype(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::UUIDType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_float_16_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::Float16Type {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_variant_type(&self) -> Option<Empty<'a>> {
    if self.logical_type_type() == LogicalType::VariantType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_geometry_type(&self) -> Option<GeometryType<'a>> {
    if self.logical_type_type() == LogicalType::GeometryType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GeometryType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn logical_type_as_geography_type(&self) -> Option<GeographyType<'a>> {
    if self.logical_type_type() == LogicalType::GeographyType {
      self.logical_type().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GeographyType::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn column_order_as_type_defined_order(&self) -> Option<Empty<'a>> {
    if self.column_order_type() == ColumnOrder::TypeDefinedOrder {
      self.column_order().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Empty::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for SchemaElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<Type>("type_", Self::VT_TYPE_, false)?
     .visit_field::<FieldRepetitionType>("repetition_type", Self::VT_REPETITION_TYPE, false)?
     .visit_union::<LogicalType, _>("logical_type_type", Self::VT_LOGICAL_TYPE_TYPE, "logical_type", Self::VT_LOGICAL_TYPE, false, |key, v, pos| {
        match key {
          LogicalType::StringType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::StringType", pos),
          LogicalType::MapType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::MapType", pos),
          LogicalType::ListType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::ListType", pos),
          LogicalType::EnumType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::EnumType", pos),
          LogicalType::DecimalType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<DecimalOpts>>("LogicalType::DecimalType", pos),
          LogicalType::DateType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::DateType", pos),
          LogicalType::TimeType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<TimeOpts>>("LogicalType::TimeType", pos),
          LogicalType::TimestampType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<TimeOpts>>("LogicalType::TimestampType", pos),
          LogicalType::IntType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<IntOpts>>("LogicalType::IntType", pos),
          LogicalType::NullType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::NullType", pos),
          LogicalType::JsonType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::JsonType", pos),
          LogicalType::BsonType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::BsonType", pos),
          LogicalType::UUIDType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::UUIDType", pos),
          LogicalType::Float16Type => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::Float16Type", pos),
          LogicalType::VariantType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("LogicalType::VariantType", pos),
          LogicalType::GeometryType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GeometryType>>("LogicalType::GeometryType", pos),
          LogicalType::GeographyType => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GeographyType>>("LogicalType::GeographyType", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i32>("type_length", Self::VT_TYPE_LENGTH, false)?
     .visit_field::<i32>("num_children", Self::VT_NUM_CHILDREN, false)?
     .visit_field::<i32>("field_id", Self::VT_FIELD_ID, false)?
     .visit_union::<ColumnOrder, _>("column_order_type", Self::VT_COLUMN_ORDER_TYPE, "column_order", Self::VT_COLUMN_ORDER, false, |key, v, pos| {
        match key {
          ColumnOrder::TypeDefinedOrder => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Empty>>("ColumnOrder::TypeDefinedOrder", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SchemaElementArgs<'a> {
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<Type>,
    pub repetition_type: FieldRepetitionType,
    pub logical_type_type: LogicalType,
    pub logical_type: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
    pub type_length: Option<i32>,
    pub num_children: i32,
    pub field_id: Option<i32>,
    pub column_order_type: ColumnOrder,
    pub column_order: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SchemaElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    SchemaElementArgs {
      name: None,
      type_: None,
      repetition_type: FieldRepetitionType::REQUIRED,
      logical_type_type: LogicalType::NONE,
      logical_type: None,
      type_length: None,
      num_children: 0,
      field_id: None,
      column_order_type: ColumnOrder::NONE,
      column_order: None,
    }
  }
}

pub struct SchemaElementBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SchemaElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SchemaElement::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: Type) {
    self.fbb_.push_slot_always::<Type>(SchemaElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_repetition_type(&mut self, repetition_type: FieldRepetitionType) {
    self.fbb_.push_slot::<FieldRepetitionType>(SchemaElement::VT_REPETITION_TYPE, repetition_type, FieldRepetitionType::REQUIRED);
  }
  #[inline]
  pub fn add_logical_type_type(&mut self, logical_type_type: LogicalType) {
    self.fbb_.push_slot::<LogicalType>(SchemaElement::VT_LOGICAL_TYPE_TYPE, logical_type_type, LogicalType::NONE);
  }
  #[inline]
  pub fn add_logical_type(&mut self, logical_type: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SchemaElement::VT_LOGICAL_TYPE, logical_type);
  }
  #[inline]
  pub fn add_type_length(&mut self, type_length: i32) {
    self.fbb_.push_slot_always::<i32>(SchemaElement::VT_TYPE_LENGTH, type_length);
  }
  #[inline]
  pub fn add_num_children(&mut self, num_children: i32) {
    self.fbb_.push_slot::<i32>(SchemaElement::VT_NUM_CHILDREN, num_children, 0);
  }
  #[inline]
  pub fn add_field_id(&mut self, field_id: i32) {
    self.fbb_.push_slot_always::<i32>(SchemaElement::VT_FIELD_ID, field_id);
  }
  #[inline]
  pub fn add_column_order_type(&mut self, column_order_type: ColumnOrder) {
    self.fbb_.push_slot::<ColumnOrder>(SchemaElement::VT_COLUMN_ORDER_TYPE, column_order_type, ColumnOrder::NONE);
  }
  #[inline]
  pub fn add_column_order(&mut self, column_order: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SchemaElement::VT_COLUMN_ORDER, column_order);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SchemaElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SchemaElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SchemaElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SchemaElement<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SchemaElement");
      ds.field("name", &self.name());
      ds.field("type_", &self.type_());
      ds.field("repetition_type", &self.repetition_type());
      ds.field("logical_type_type", &self.logical_type_type());
      match self.logical_type_type() {
        LogicalType::StringType => {
          if let Some(x) = self.logical_type_as_string_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::MapType => {
          if let Some(x) = self.logical_type_as_map_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::ListType => {
          if let Some(x) = self.logical_type_as_list_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::EnumType => {
          if let Some(x) = self.logical_type_as_enum_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::DecimalType => {
          if let Some(x) = self.logical_type_as_decimal_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::DateType => {
          if let Some(x) = self.logical_type_as_date_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::TimeType => {
          if let Some(x) = self.logical_type_as_time_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::TimestampType => {
          if let Some(x) = self.logical_type_as_timestamp_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::IntType => {
          if let Some(x) = self.logical_type_as_int_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::NullType => {
          if let Some(x) = self.logical_type_as_null_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::JsonType => {
          if let Some(x) = self.logical_type_as_json_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::BsonType => {
          if let Some(x) = self.logical_type_as_bson_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::UUIDType => {
          if let Some(x) = self.logical_type_as_uuidtype() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::Float16Type => {
          if let Some(x) = self.logical_type_as_float_16_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::VariantType => {
          if let Some(x) = self.logical_type_as_variant_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::GeometryType => {
          if let Some(x) = self.logical_type_as_geometry_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LogicalType::GeographyType => {
          if let Some(x) = self.logical_type_as_geography_type() {
            ds.field("logical_type", &x)
          } else {
            ds.field("logical_type", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("logical_type", &x)
        },
      };
      ds.field("type_length", &self.type_length());
      ds.field("num_children", &self.num_children());
      ds.field("field_id", &self.field_id());
      ds.field("column_order_type", &self.column_order_type());
      match self.column_order_type() {
        ColumnOrder::TypeDefinedOrder => {
          if let Some(x) = self.column_order_as_type_defined_order() {
            ds.field("column_order", &x)
          } else {
            ds.field("column_order", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("column_order", &x)
        },
      };
      ds.finish()
  }
}
pub enum KVOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KV<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for KV<'a> {
  type Inner = KV<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> KV<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_VAL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    KV { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KVArgs<'args>
  ) -> ::flatbuffers::WIPOffset<KV<'bldr>> {
    let mut builder = KVBuilder::new(_fbb);
    if let Some(x) = args.val { builder.add_val(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(KV::VT_KEY, None)}
  }
  #[inline]
  pub fn val(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(KV::VT_VAL, None)}
  }
}

impl ::flatbuffers::Verifiable for KV<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("val", Self::VT_VAL, false)?
     .finish();
    Ok(())
  }
}
pub struct KVArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub val: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KVArgs<'a> {
  #[inline]
  fn default() -> Self {
    KVArgs {
      key: None,
      val: None,
    }
  }
}

pub struct KVBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> KVBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(KV::VT_KEY, key);
  }
  #[inline]
  pub fn add_val(&mut self, val: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(KV::VT_VAL, val);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> KVBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KVBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<KV<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for KV<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("KV");
      ds.field("key", &self.key());
      ds.field("val", &self.val());
      ds.finish()
  }
}
pub enum ColumnMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnMetadata<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ColumnMetadata<'a> {
  type Inner = ColumnMetadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ColumnMetadata<'a> {
  pub const VT_CODEC: ::flatbuffers::VOffsetT = 4;
  pub const VT_NUM_VALUES: ::flatbuffers::VOffsetT = 6;
  pub const VT_TOTAL_UNCOMPRESSED_SIZE: ::flatbuffers::VOffsetT = 8;
  pub const VT_TOTAL_COMPRESSED_SIZE: ::flatbuffers::VOffsetT = 10;
  pub const VT_KEY_VALUE_METADATA: ::flatbuffers::VOffsetT = 12;
  pub const VT_DATA_PAGE_OFFSET: ::flatbuffers::VOffsetT = 14;
  pub const VT_INDEX_PAGE_OFFSET: ::flatbuffers::VOffsetT = 16;
  pub const VT_DICTIONARY_PAGE_OFFSET: ::flatbuffers::VOffsetT = 18;
  pub const VT_STATISTICS: ::flatbuffers::VOffsetT = 20;
  pub const VT_IS_FULLY_DICT_ENCODED: ::flatbuffers::VOffsetT = 22;
  pub const VT_BLOOM_FILTER_OFFSET: ::flatbuffers::VOffsetT = 24;
  pub const VT_BLOOM_FILTER_LENGTH: ::flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ColumnMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnMetadataArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ColumnMetadata<'bldr>> {
    let mut builder = ColumnMetadataBuilder::new(_fbb);
    if let Some(x) = args.bloom_filter_offset { builder.add_bloom_filter_offset(x); }
    if let Some(x) = args.dictionary_page_offset { builder.add_dictionary_page_offset(x); }
    if let Some(x) = args.index_page_offset { builder.add_index_page_offset(x); }
    builder.add_data_page_offset(args.data_page_offset);
    builder.add_total_compressed_size(args.total_compressed_size);
    builder.add_total_uncompressed_size(args.total_uncompressed_size);
    if let Some(x) = args.num_values { builder.add_num_values(x); }
    if let Some(x) = args.bloom_filter_length { builder.add_bloom_filter_length(x); }
    if let Some(x) = args.statistics { builder.add_statistics(x); }
    if let Some(x) = args.key_value_metadata { builder.add_key_value_metadata(x); }
    builder.add_is_fully_dict_encoded(args.is_fully_dict_encoded);
    builder.add_codec(args.codec);
    builder.finish()
  }


  #[inline]
  pub fn codec(&self) -> CompressionCodec {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CompressionCodec>(ColumnMetadata::VT_CODEC, Some(CompressionCodec::UNCOMPRESSED)).unwrap()}
  }
  #[inline]
  pub fn num_values(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_NUM_VALUES, None)}
  }
  #[inline]
  pub fn total_uncompressed_size(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_TOTAL_UNCOMPRESSED_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_compressed_size(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_TOTAL_COMPRESSED_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_value_metadata(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV>>>>(ColumnMetadata::VT_KEY_VALUE_METADATA, None)}
  }
  #[inline]
  pub fn data_page_offset(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_DATA_PAGE_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index_page_offset(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_INDEX_PAGE_OFFSET, None)}
  }
  #[inline]
  pub fn dictionary_page_offset(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_DICTIONARY_PAGE_OFFSET, None)}
  }
  #[inline]
  pub fn statistics(&self) -> Option<Statistics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<Statistics>>(ColumnMetadata::VT_STATISTICS, None)}
  }
  #[inline]
  pub fn is_fully_dict_encoded(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ColumnMetadata::VT_IS_FULLY_DICT_ENCODED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn bloom_filter_offset(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(ColumnMetadata::VT_BLOOM_FILTER_OFFSET, None)}
  }
  #[inline]
  pub fn bloom_filter_length(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ColumnMetadata::VT_BLOOM_FILTER_LENGTH, None)}
  }
}

impl ::flatbuffers::Verifiable for ColumnMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<CompressionCodec>("codec", Self::VT_CODEC, false)?
     .visit_field::<i64>("num_values", Self::VT_NUM_VALUES, false)?
     .visit_field::<i64>("total_uncompressed_size", Self::VT_TOTAL_UNCOMPRESSED_SIZE, false)?
     .visit_field::<i64>("total_compressed_size", Self::VT_TOTAL_COMPRESSED_SIZE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<KV>>>>("key_value_metadata", Self::VT_KEY_VALUE_METADATA, false)?
     .visit_field::<i64>("data_page_offset", Self::VT_DATA_PAGE_OFFSET, false)?
     .visit_field::<i64>("index_page_offset", Self::VT_INDEX_PAGE_OFFSET, false)?
     .visit_field::<i64>("dictionary_page_offset", Self::VT_DICTIONARY_PAGE_OFFSET, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<Statistics>>("statistics", Self::VT_STATISTICS, false)?
     .visit_field::<bool>("is_fully_dict_encoded", Self::VT_IS_FULLY_DICT_ENCODED, false)?
     .visit_field::<i64>("bloom_filter_offset", Self::VT_BLOOM_FILTER_OFFSET, false)?
     .visit_field::<i32>("bloom_filter_length", Self::VT_BLOOM_FILTER_LENGTH, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnMetadataArgs<'a> {
    pub codec: CompressionCodec,
    pub num_values: Option<i64>,
    pub total_uncompressed_size: i64,
    pub total_compressed_size: i64,
    pub key_value_metadata: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV<'a>>>>>,
    pub data_page_offset: i64,
    pub index_page_offset: Option<i64>,
    pub dictionary_page_offset: Option<i64>,
    pub statistics: Option<::flatbuffers::WIPOffset<Statistics<'a>>>,
    pub is_fully_dict_encoded: bool,
    pub bloom_filter_offset: Option<i64>,
    pub bloom_filter_length: Option<i32>,
}
impl<'a> Default for ColumnMetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnMetadataArgs {
      codec: CompressionCodec::UNCOMPRESSED,
      num_values: None,
      total_uncompressed_size: 0,
      total_compressed_size: 0,
      key_value_metadata: None,
      data_page_offset: 0,
      index_page_offset: None,
      dictionary_page_offset: None,
      statistics: None,
      is_fully_dict_encoded: false,
      bloom_filter_offset: None,
      bloom_filter_length: None,
    }
  }
}

pub struct ColumnMetadataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ColumnMetadataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_codec(&mut self, codec: CompressionCodec) {
    self.fbb_.push_slot::<CompressionCodec>(ColumnMetadata::VT_CODEC, codec, CompressionCodec::UNCOMPRESSED);
  }
  #[inline]
  pub fn add_num_values(&mut self, num_values: i64) {
    self.fbb_.push_slot_always::<i64>(ColumnMetadata::VT_NUM_VALUES, num_values);
  }
  #[inline]
  pub fn add_total_uncompressed_size(&mut self, total_uncompressed_size: i64) {
    self.fbb_.push_slot::<i64>(ColumnMetadata::VT_TOTAL_UNCOMPRESSED_SIZE, total_uncompressed_size, 0);
  }
  #[inline]
  pub fn add_total_compressed_size(&mut self, total_compressed_size: i64) {
    self.fbb_.push_slot::<i64>(ColumnMetadata::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, 0);
  }
  #[inline]
  pub fn add_key_value_metadata(&mut self, key_value_metadata: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<KV<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ColumnMetadata::VT_KEY_VALUE_METADATA, key_value_metadata);
  }
  #[inline]
  pub fn add_data_page_offset(&mut self, data_page_offset: i64) {
    self.fbb_.push_slot::<i64>(ColumnMetadata::VT_DATA_PAGE_OFFSET, data_page_offset, 0);
  }
  #[inline]
  pub fn add_index_page_offset(&mut self, index_page_offset: i64) {
    self.fbb_.push_slot_always::<i64>(ColumnMetadata::VT_INDEX_PAGE_OFFSET, index_page_offset);
  }
  #[inline]
  pub fn add_dictionary_page_offset(&mut self, dictionary_page_offset: i64) {
    self.fbb_.push_slot_always::<i64>(ColumnMetadata::VT_DICTIONARY_PAGE_OFFSET, dictionary_page_offset);
  }
  #[inline]
  pub fn add_statistics(&mut self, statistics: ::flatbuffers::WIPOffset<Statistics<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<Statistics>>(ColumnMetadata::VT_STATISTICS, statistics);
  }
  #[inline]
  pub fn add_is_fully_dict_encoded(&mut self, is_fully_dict_encoded: bool) {
    self.fbb_.push_slot::<bool>(ColumnMetadata::VT_IS_FULLY_DICT_ENCODED, is_fully_dict_encoded, false);
  }
  #[inline]
  pub fn add_bloom_filter_offset(&mut self, bloom_filter_offset: i64) {
    self.fbb_.push_slot_always::<i64>(ColumnMetadata::VT_BLOOM_FILTER_OFFSET, bloom_filter_offset);
  }
  #[inline]
  pub fn add_bloom_filter_length(&mut self, bloom_filter_length: i32) {
    self.fbb_.push_slot_always::<i32>(ColumnMetadata::VT_BLOOM_FILTER_LENGTH, bloom_filter_length);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnMetadataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ColumnMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ColumnMetadata<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ColumnMetadata");
      ds.field("codec", &self.codec());
      ds.field("num_values", &self.num_values());
      ds.field("total_uncompressed_size", &self.total_uncompressed_size());
      ds.field("total_compressed_size", &self.total_compressed_size());
      ds.field("key_value_metadata", &self.key_value_metadata());
      ds.field("data_page_offset", &self.data_page_offset());
      ds.field("index_page_offset", &self.index_page_offset());
      ds.field("dictionary_page_offset", &self.dictionary_page_offset());
      ds.field("statistics", &self.statistics());
      ds.field("is_fully_dict_encoded", &self.is_fully_dict_encoded());
      ds.field("bloom_filter_offset", &self.bloom_filter_offset());
      ds.field("bloom_filter_length", &self.bloom_filter_length());
      ds.finish()
  }
}
pub enum ColumnChunkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnChunk<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ColumnChunk<'a> {
  type Inner = ColumnChunk<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ColumnChunk<'a> {
  pub const VT_FILE_PATH: ::flatbuffers::VOffsetT = 4;
  pub const VT_META_DATA: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ColumnChunk { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnChunkArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ColumnChunk<'bldr>> {
    let mut builder = ColumnChunkBuilder::new(_fbb);
    if let Some(x) = args.meta_data { builder.add_meta_data(x); }
    if let Some(x) = args.file_path { builder.add_file_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn file_path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(ColumnChunk::VT_FILE_PATH, None)}
  }
  #[inline]
  pub fn meta_data(&self) -> Option<ColumnMetadata<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<ColumnMetadata>>(ColumnChunk::VT_META_DATA, None)}
  }
}

impl ::flatbuffers::Verifiable for ColumnChunk<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("file_path", Self::VT_FILE_PATH, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<ColumnMetadata>>("meta_data", Self::VT_META_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnChunkArgs<'a> {
    pub file_path: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub meta_data: Option<::flatbuffers::WIPOffset<ColumnMetadata<'a>>>,
}
impl<'a> Default for ColumnChunkArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnChunkArgs {
      file_path: None,
      meta_data: None,
    }
  }
}

pub struct ColumnChunkBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ColumnChunkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_file_path(&mut self, file_path: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ColumnChunk::VT_FILE_PATH, file_path);
  }
  #[inline]
  pub fn add_meta_data(&mut self, meta_data: ::flatbuffers::WIPOffset<ColumnMetadata<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<ColumnMetadata>>(ColumnChunk::VT_META_DATA, meta_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnChunkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ColumnChunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ColumnChunk<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ColumnChunk");
      ds.field("file_path", &self.file_path());
      ds.field("meta_data", &self.meta_data());
      ds.finish()
  }
}
pub enum SortingColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SortingColumn<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for SortingColumn<'a> {
  type Inner = SortingColumn<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SortingColumn<'a> {
  pub const VT_COLUMN_IDX: ::flatbuffers::VOffsetT = 4;
  pub const VT_DESCENDING: ::flatbuffers::VOffsetT = 6;
  pub const VT_NULLS_FIRST: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SortingColumn { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SortingColumnArgs
  ) -> ::flatbuffers::WIPOffset<SortingColumn<'bldr>> {
    let mut builder = SortingColumnBuilder::new(_fbb);
    builder.add_column_idx(args.column_idx);
    builder.add_nulls_first(args.nulls_first);
    builder.add_descending(args.descending);
    builder.finish()
  }


  #[inline]
  pub fn column_idx(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SortingColumn::VT_COLUMN_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn descending(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SortingColumn::VT_DESCENDING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn nulls_first(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SortingColumn::VT_NULLS_FIRST, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for SortingColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("column_idx", Self::VT_COLUMN_IDX, false)?
     .visit_field::<bool>("descending", Self::VT_DESCENDING, false)?
     .visit_field::<bool>("nulls_first", Self::VT_NULLS_FIRST, false)?
     .finish();
    Ok(())
  }
}
pub struct SortingColumnArgs {
    pub column_idx: i32,
    pub descending: bool,
    pub nulls_first: bool,
}
impl<'a> Default for SortingColumnArgs {
  #[inline]
  fn default() -> Self {
    SortingColumnArgs {
      column_idx: 0,
      descending: false,
      nulls_first: false,
    }
  }
}

pub struct SortingColumnBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SortingColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_column_idx(&mut self, column_idx: i32) {
    self.fbb_.push_slot::<i32>(SortingColumn::VT_COLUMN_IDX, column_idx, 0);
  }
  #[inline]
  pub fn add_descending(&mut self, descending: bool) {
    self.fbb_.push_slot::<bool>(SortingColumn::VT_DESCENDING, descending, false);
  }
  #[inline]
  pub fn add_nulls_first(&mut self, nulls_first: bool) {
    self.fbb_.push_slot::<bool>(SortingColumn::VT_NULLS_FIRST, nulls_first, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SortingColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SortingColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SortingColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SortingColumn<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SortingColumn");
      ds.field("column_idx", &self.column_idx());
      ds.field("descending", &self.descending());
      ds.field("nulls_first", &self.nulls_first());
      ds.finish()
  }
}
pub enum RowGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RowGroup<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for RowGroup<'a> {
  type Inner = RowGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> RowGroup<'a> {
  pub const VT_COLUMNS: ::flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL_BYTE_SIZE: ::flatbuffers::VOffsetT = 6;
  pub const VT_NUM_ROWS: ::flatbuffers::VOffsetT = 8;
  pub const VT_SORTING_COLUMNS: ::flatbuffers::VOffsetT = 10;
  pub const VT_FILE_OFFSET: ::flatbuffers::VOffsetT = 12;
  pub const VT_TOTAL_COMPRESSED_SIZE: ::flatbuffers::VOffsetT = 14;
  pub const VT_ORDINAL: ::flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    RowGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RowGroupArgs<'args>
  ) -> ::flatbuffers::WIPOffset<RowGroup<'bldr>> {
    let mut builder = RowGroupBuilder::new(_fbb);
    builder.add_total_compressed_size(args.total_compressed_size);
    builder.add_file_offset(args.file_offset);
    builder.add_num_rows(args.num_rows);
    builder.add_total_byte_size(args.total_byte_size);
    if let Some(x) = args.sorting_columns { builder.add_sorting_columns(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.ordinal { builder.add_ordinal(x); }
    builder.finish()
  }


  #[inline]
  pub fn columns(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnChunk<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnChunk>>>>(RowGroup::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn total_byte_size(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RowGroup::VT_TOTAL_BYTE_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn num_rows(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RowGroup::VT_NUM_ROWS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sorting_columns(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SortingColumn<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SortingColumn>>>>(RowGroup::VT_SORTING_COLUMNS, None)}
  }
  #[inline]
  pub fn file_offset(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RowGroup::VT_FILE_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_compressed_size(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(RowGroup::VT_TOTAL_COMPRESSED_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ordinal(&self) -> Option<i16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(RowGroup::VT_ORDINAL, None)}
  }
}

impl ::flatbuffers::Verifiable for RowGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<ColumnChunk>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<i64>("total_byte_size", Self::VT_TOTAL_BYTE_SIZE, false)?
     .visit_field::<i64>("num_rows", Self::VT_NUM_ROWS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<SortingColumn>>>>("sorting_columns", Self::VT_SORTING_COLUMNS, false)?
     .visit_field::<i64>("file_offset", Self::VT_FILE_OFFSET, false)?
     .visit_field::<i64>("total_compressed_size", Self::VT_TOTAL_COMPRESSED_SIZE, false)?
     .visit_field::<i16>("ordinal", Self::VT_ORDINAL, false)?
     .finish();
    Ok(())
  }
}
pub struct RowGroupArgs<'a> {
    pub columns: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnChunk<'a>>>>>,
    pub total_byte_size: i64,
    pub num_rows: i64,
    pub sorting_columns: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SortingColumn<'a>>>>>,
    pub file_offset: i64,
    pub total_compressed_size: i64,
    pub ordinal: Option<i16>,
}
impl<'a> Default for RowGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    RowGroupArgs {
      columns: None,
      total_byte_size: 0,
      num_rows: 0,
      sorting_columns: None,
      file_offset: 0,
      total_compressed_size: 0,
      ordinal: None,
    }
  }
}

pub struct RowGroupBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RowGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_columns(&mut self, columns: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<ColumnChunk<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RowGroup::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_total_byte_size(&mut self, total_byte_size: i64) {
    self.fbb_.push_slot::<i64>(RowGroup::VT_TOTAL_BYTE_SIZE, total_byte_size, 0);
  }
  #[inline]
  pub fn add_num_rows(&mut self, num_rows: i64) {
    self.fbb_.push_slot::<i64>(RowGroup::VT_NUM_ROWS, num_rows, 0);
  }
  #[inline]
  pub fn add_sorting_columns(&mut self, sorting_columns: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<SortingColumn<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RowGroup::VT_SORTING_COLUMNS, sorting_columns);
  }
  #[inline]
  pub fn add_file_offset(&mut self, file_offset: i64) {
    self.fbb_.push_slot::<i64>(RowGroup::VT_FILE_OFFSET, file_offset, 0);
  }
  #[inline]
  pub fn add_total_compressed_size(&mut self, total_compressed_size: i64) {
    self.fbb_.push_slot::<i64>(RowGroup::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, 0);
  }
  #[inline]
  pub fn add_ordinal(&mut self, ordinal: i16) {
    self.fbb_.push_slot_always::<i16>(RowGroup::VT_ORDINAL, ordinal);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> RowGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RowGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<RowGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for RowGroup<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("RowGroup");
      ds.field("columns", &self.columns());
      ds.field("total_byte_size", &self.total_byte_size());
      ds.field("num_rows", &self.num_rows());
      ds.field("sorting_columns", &self.sorting_columns());
      ds.field("file_offset", &self.file_offset());
      ds.field("total_compressed_size", &self.total_compressed_size());
      ds.field("ordinal", &self.ordinal());
      ds.finish()
  }
}
pub enum FileMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FileMetaData<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for FileMetaData<'a> {
  type Inner = FileMetaData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> FileMetaData<'a> {
  pub const VT_VERSION: ::flatbuffers::VOffsetT = 4;
  pub const VT_SCHEMA: ::flatbuffers::VOffsetT = 6;
  pub const VT_NUM_ROWS: ::flatbuffers::VOffsetT = 8;
  pub const VT_ROW_GROUPS: ::flatbuffers::VOffsetT = 10;
  pub const VT_KV: ::flatbuffers::VOffsetT = 12;
  pub const VT_CREATED_BY: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    FileMetaData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FileMetaDataArgs<'args>
  ) -> ::flatbuffers::WIPOffset<FileMetaData<'bldr>> {
    let mut builder = FileMetaDataBuilder::new(_fbb);
    builder.add_num_rows(args.num_rows);
    if let Some(x) = args.created_by { builder.add_created_by(x); }
    if let Some(x) = args.kv { builder.add_kv(x); }
    if let Some(x) = args.row_groups { builder.add_row_groups(x); }
    if let Some(x) = args.schema { builder.add_schema(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(FileMetaData::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn schema(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SchemaElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SchemaElement>>>>(FileMetaData::VT_SCHEMA, None)}
  }
  #[inline]
  pub fn num_rows(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(FileMetaData::VT_NUM_ROWS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn row_groups(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RowGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RowGroup>>>>(FileMetaData::VT_ROW_GROUPS, None)}
  }
  #[inline]
  pub fn kv(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV>>>>(FileMetaData::VT_KV, None)}
  }
  #[inline]
  pub fn created_by(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(FileMetaData::VT_CREATED_BY, None)}
  }
}

impl ::flatbuffers::Verifiable for FileMetaData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<SchemaElement>>>>("schema", Self::VT_SCHEMA, false)?
     .visit_field::<i64>("num_rows", Self::VT_NUM_ROWS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<RowGroup>>>>("row_groups", Self::VT_ROW_GROUPS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<KV>>>>("kv", Self::VT_KV, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("created_by", Self::VT_CREATED_BY, false)?
     .finish();
    Ok(())
  }
}
pub struct FileMetaDataArgs<'a> {
    pub version: i32,
    pub schema: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SchemaElement<'a>>>>>,
    pub num_rows: i64,
    pub row_groups: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<RowGroup<'a>>>>>,
    pub kv: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KV<'a>>>>>,
    pub created_by: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FileMetaDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileMetaDataArgs {
      version: 0,
      schema: None,
      num_rows: 0,
      row_groups: None,
      kv: None,
      created_by: None,
    }
  }
}

pub struct FileMetaDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FileMetaDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(FileMetaData::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_schema(&mut self, schema: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<SchemaElement<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FileMetaData::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_num_rows(&mut self, num_rows: i64) {
    self.fbb_.push_slot::<i64>(FileMetaData::VT_NUM_ROWS, num_rows, 0);
  }
  #[inline]
  pub fn add_row_groups(&mut self, row_groups: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<RowGroup<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FileMetaData::VT_ROW_GROUPS, row_groups);
  }
  #[inline]
  pub fn add_kv(&mut self, kv: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<KV<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FileMetaData::VT_KV, kv);
  }
  #[inline]
  pub fn add_created_by(&mut self, created_by: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(FileMetaData::VT_CREATED_BY, created_by);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> FileMetaDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FileMetaDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<FileMetaData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for FileMetaData<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("FileMetaData");
      ds.field("version", &self.version());
      ds.field("schema", &self.schema());
      ds.field("num_rows", &self.num_rows());
      ds.field("row_groups", &self.row_groups());
      ds.field("kv", &self.kv());
      ds.field("created_by", &self.created_by());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FileMetaData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_meta_data_unchecked`.
pub fn root_as_file_meta_data(buf: &[u8]) -> Result<FileMetaData<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<FileMetaData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FileMetaData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_file_meta_data_unchecked`.
pub fn size_prefixed_root_as_file_meta_data(buf: &[u8]) -> Result<FileMetaData<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<FileMetaData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FileMetaData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_meta_data_unchecked`.
pub fn root_as_file_meta_data_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FileMetaData<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<FileMetaData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FileMetaData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_file_meta_data_unchecked`.
pub fn size_prefixed_root_as_file_meta_data_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FileMetaData<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<FileMetaData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FileMetaData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FileMetaData`.
pub unsafe fn root_as_file_meta_data_unchecked(buf: &[u8]) -> FileMetaData<'_> {
  unsafe { ::flatbuffers::root_unchecked::<FileMetaData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FileMetaData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FileMetaData`.
pub unsafe fn size_prefixed_root_as_file_meta_data_unchecked(buf: &[u8]) -> FileMetaData<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<FileMetaData>(buf) }
}
#[inline]
pub fn finish_file_meta_data_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<FileMetaData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_file_meta_data_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<FileMetaData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod format3
}  // pub mod parquet

