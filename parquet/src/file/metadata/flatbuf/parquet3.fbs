// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// FlatBuffers schema for Parquet metadata (format version 3).
//
// This schema mirrors the metadata structures defined in parquet.thrift but uses
// FlatBuffers for more efficient serialization (zero-copy reads, smaller encoding).
//
// Key differences from parquet.thrift:
// 1. Statistics are stored in integral types if their size is fixed, otherwise prefix + suffix
// 2. ColumnMetaData.encoding_stats are removed, replaced with
//    ColumnMetaData.is_fully_dict_encoded.
// 3. RowGroups are limited to 2GB in size, so we can use int for sizes.
// 4. ColumnChunk/ColumnMetaData offsets are now relative to the start of the row group, so we can
//    use int for offsets.
// 5. RowGroup ordinal is removed (derivable from position in the row_groups vector).
// 6. Restrict RowGroups to 2^31-1 rows.
// 7. Remove offset/column indexes, they are small and just their offsets are of similar size.
//
// Related:
//   - parquet.thrift: https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift
//   - C++ implementation: https://github.com/apache/arrow/pull/48431
//   - Format proposal: https://github.com/apache/parquet-format/pull/544

namespace parquet.format3;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Physical types.
///////////////////////////////////////////////////////////////////////////////////////////////////

enum Type : byte {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7,
}

enum FieldRepetitionType : byte {
  REQUIRED = 0,
  OPTIONAL = 1,
  REPEATED = 2,
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Encodings.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Note: Match the thrift enum values so that we can cast between them.
enum Encoding : byte {
  PLAIN = 0,
  // GROUP_VAR_INT = 1,  // deprecated
  PLAIN_DICTIONARY = 2,
  RLE = 3,
  // BIT_PACKED = 4,  // deprecated
  DELTA_BINARY_PACKED = 5,
  DELTA_LENGTH_BYTE_ARRAY = 6,
  DELTA_BYTE_ARRAY = 7,
  RLE_DICTIONARY = 8,
  BYTE_STREAM_SPLIT = 9,
}

// Note: Match the thrift enum values so that we can cast between them.
enum CompressionCodec : byte {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4,
  // LZ4 = 5,  // deprecated, use LZ4_RAW instead
  ZSTD = 6,
  LZ4_RAW = 7,
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Logical types.
///////////////////////////////////////////////////////////////////////////////////////////////////

table Empty {}
table DecimalOptions {
  precision: int;
  scale: int;
}
enum TimeUnit : byte {
  Millisecond = 0,
  Microsecond = 1,
  Nanosecond = 2,
}
table TimeOptions {
  is_adjusted_to_utc: bool;
  unit: TimeUnit;
}
table IntOptions {
  bit_width: byte = 8;
  is_signed: bool;
}
table GeometryType {
  crs: string;
}
enum EdgeInterpolationAlgorithm : byte {
  SPHERICAL = 0,
  VINCENTY = 1,
  THOMAS = 2,
  ANDOYER = 3,
  KARNEY = 4,
}
table GeographyType {
  crs: string;
  algorithm: EdgeInterpolationAlgorithm;
}
union LogicalType {
  StringType:Empty,
  MapType:Empty,
  ListType:Empty,
  EnumType:Empty,
  DecimalType:DecimalOptions,
  DateType:Empty,
  TimeType:TimeOptions,
  TimestampType:TimeOptions,
  IntType:IntOptions,
  NullType:Empty,
  JsonType:Empty,
  BsonType:Empty,
  UUIDType:Empty,
  Float16Type:Empty,
  VariantType:Empty,
  GeometryType:GeometryType,
  GeographyType:GeographyType,
}

// Statistics for a column chunk, packed into integral fields.
//
// Min/max values are stored depending on the physical type:
// - BOOLEAN: none (no min/max stored)
// - INT32/FLOAT: lo4 contains the 4-byte little-endian value
// - INT64/DOUBLE: lo8 contains the 8-byte little-endian value
// - INT96: lo4 contains bytes [0..4), lo8 contains bytes [4..12) (little-endian)
// - BYTE_ARRAY / FIXED_LEN_BYTE_ARRAY:
//     prefix: the longest common prefix of min and max
//     The suffix (value after removing prefix) is stored as:
//       lo8+hi8: zero-padded 16 bytes (big-endian) of the suffix
//       len: the length of the suffix. If abs(len) > 16 then the value is inexact.
//     A negative len indicates the original value was truncated (inexact).
//
// Example for INT32 with min=42, max=100:
//   min_lo4=42, min_len=4, max_lo4=100, max_len=4
//
// Example for BYTE_ARRAY with min="hello", max="help":
//   prefix="hel", min_lo4=0x6C6F0000 (big-endian "lo"), min_len=2,
//   max_lo4=0x70000000 (big-endian "p"), max_len=1
table Statistics {
  null_count: int = null;
  min_lo4: uint;
  min_lo8: ulong;
  min_hi8: ulong;
  min_len: byte = null;
  max_lo4: uint;
  max_lo8: ulong;
  max_hi8: ulong;
  max_len: byte = null;
  prefix: string;
}

union ColumnOrder {
  TypeDefinedOrder:Empty,
}

table SchemaElement {
  name: string;
  type: Type = null;
  repetition_type: FieldRepetitionType;
  logical_type: LogicalType;
  type_length: int = null;
  num_children: int = 0;
  field_id: int = null;
  column_order: ColumnOrder;  // only present for leaf nodes
}

enum PageType : byte {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3,
}

table KeyValue {
  key: string;
  val: string;
}

table ColumnMetadata {
  codec: CompressionCodec;
  num_values: long = null;  // only present if not equal to rg.num_rows
  total_uncompressed_size: long;
  total_compressed_size: long;
  key_value_metadata: [KeyValue];
  data_page_offset: long;
  index_page_offset: long = null;
  dictionary_page_offset: long = null;
  statistics: Statistics;
  is_fully_dict_encoded: bool;
  bloom_filter_offset: long = null;
  bloom_filter_length: int = null;
}

table ColumnChunk {
  file_path: string;
  meta_data: ColumnMetadata;
  // crypto_metadata: ColumnCryptoMetadata;  // TODO
  // encrypted_column_metadata: [byte];  // TODO
}

table SortingColumn {
  column_idx: int;
  descending: bool;
  nulls_first: bool;
}

table RowGroup {
  columns: [ColumnChunk];
  total_byte_size: long;
  num_rows: long;
  sorting_columns: [SortingColumn];
  file_offset: long;
  total_compressed_size: long;
}

table FileMetaData {
  version: int;
  schema: [SchemaElement];
  num_rows: long;
  row_groups: [RowGroup];
  kv: [KeyValue];
  created_by: string;
  // column_orders: [ColumnOrder];  // moved to SchemaElement
  // encryption_algorithm: [EncryptionAlgorithm];  // TODO
  // footer_signing_key_metadata: binary;  // TODO
}

root_type FileMetaData;
