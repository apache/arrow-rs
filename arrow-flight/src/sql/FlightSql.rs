pub mod proto {
// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `FlightSql.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetSqlInfo {
    // message fields
    pub info: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetSqlInfo {
    fn default() -> &'a CommandGetSqlInfo {
        <CommandGetSqlInfo as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetSqlInfo {
    pub fn new() -> CommandGetSqlInfo {
        ::std::default::Default::default()
    }

    // repeated uint32 info = 1;


    pub fn get_info(&self) -> &[u32] {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::vec::Vec<u32>) {
        self.info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_info(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.info, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandGetSqlInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.info {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.info {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetSqlInfo {
        CommandGetSqlInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "info",
                |m: &CommandGetSqlInfo| { &m.info },
                |m: &mut CommandGetSqlInfo| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetSqlInfo>(
                "CommandGetSqlInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetSqlInfo {
        static instance: ::protobuf::rt::LazyV2<CommandGetSqlInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetSqlInfo::new)
    }
}

impl ::protobuf::Clear for CommandGetSqlInfo {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetSqlInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetSqlInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetCatalogs {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetCatalogs {
    fn default() -> &'a CommandGetCatalogs {
        <CommandGetCatalogs as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetCatalogs {
    pub fn new() -> CommandGetCatalogs {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandGetCatalogs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetCatalogs {
        CommandGetCatalogs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetCatalogs>(
                "CommandGetCatalogs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetCatalogs {
        static instance: ::protobuf::rt::LazyV2<CommandGetCatalogs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetCatalogs::new)
    }
}

impl ::protobuf::Clear for CommandGetCatalogs {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetCatalogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetCatalogs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetDbSchemas {
    // message oneof groups
    pub _catalog: ::std::option::Option<CommandGetDbSchemas_oneof__catalog>,
    pub _db_schema_filter_pattern: ::std::option::Option<CommandGetDbSchemas_oneof__db_schema_filter_pattern>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetDbSchemas {
    fn default() -> &'a CommandGetDbSchemas {
        <CommandGetDbSchemas as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetDbSchemas_oneof__catalog {
    catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetDbSchemas_oneof__db_schema_filter_pattern {
    db_schema_filter_pattern(::std::string::String),
}

impl CommandGetDbSchemas {
    pub fn new() -> CommandGetDbSchemas {
        ::std::default::Default::default()
    }

    // string catalog = 1;


    pub fn get_catalog(&self) -> &str {
        match self._catalog {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_catalog(&mut self) {
        self._catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        match self._catalog {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: ::std::string::String) {
        self._catalog = ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(_)) = self._catalog {
        } else {
            self._catalog = ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(::std::string::String::new()));
        }
        match self._catalog {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_catalog(&mut self) -> ::std::string::String {
        if self.has_catalog() {
            match self._catalog.take() {
                ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string db_schema_filter_pattern = 2;


    pub fn get_db_schema_filter_pattern(&self) -> &str {
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_db_schema_filter_pattern(&mut self) {
        self._db_schema_filter_pattern = ::std::option::Option::None;
    }

    pub fn has_db_schema_filter_pattern(&self) -> bool {
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_db_schema_filter_pattern(&mut self, v: ::std::string::String) {
        self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(v))
    }

    // Mutable pointer to the field.
    pub fn mut_db_schema_filter_pattern(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(_)) = self._db_schema_filter_pattern {
        } else {
            self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(::std::string::String::new()));
        }
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_db_schema_filter_pattern(&mut self) -> ::std::string::String {
        if self.has_db_schema_filter_pattern() {
            match self._db_schema_filter_pattern.take() {
                ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for CommandGetDbSchemas {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._catalog = ::std::option::Option::Some(CommandGetDbSchemas_oneof__catalog::catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetDbSchemas_oneof__catalog::catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema_filter_pattern {
            match v {
                &CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetDbSchemas_oneof__catalog::catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema_filter_pattern {
            match v {
                &CommandGetDbSchemas_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetDbSchemas {
        CommandGetDbSchemas::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "catalog",
                CommandGetDbSchemas::has_catalog,
                CommandGetDbSchemas::get_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "db_schema_filter_pattern",
                CommandGetDbSchemas::has_db_schema_filter_pattern,
                CommandGetDbSchemas::get_db_schema_filter_pattern,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetDbSchemas>(
                "CommandGetDbSchemas",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetDbSchemas {
        static instance: ::protobuf::rt::LazyV2<CommandGetDbSchemas> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetDbSchemas::new)
    }
}

impl ::protobuf::Clear for CommandGetDbSchemas {
    fn clear(&mut self) {
        self._catalog = ::std::option::Option::None;
        self._db_schema_filter_pattern = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetDbSchemas {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetDbSchemas {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetTables {
    // message fields
    pub table_types: ::protobuf::RepeatedField<::std::string::String>,
    pub include_schema: bool,
    // message oneof groups
    pub _catalog: ::std::option::Option<CommandGetTables_oneof__catalog>,
    pub _db_schema_filter_pattern: ::std::option::Option<CommandGetTables_oneof__db_schema_filter_pattern>,
    pub _table_name_filter_pattern: ::std::option::Option<CommandGetTables_oneof__table_name_filter_pattern>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetTables {
    fn default() -> &'a CommandGetTables {
        <CommandGetTables as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetTables_oneof__catalog {
    catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetTables_oneof__db_schema_filter_pattern {
    db_schema_filter_pattern(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetTables_oneof__table_name_filter_pattern {
    table_name_filter_pattern(::std::string::String),
}

impl CommandGetTables {
    pub fn new() -> CommandGetTables {
        ::std::default::Default::default()
    }

    // string catalog = 1;


    pub fn get_catalog(&self) -> &str {
        match self._catalog {
            ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_catalog(&mut self) {
        self._catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        match self._catalog {
            ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: ::std::string::String) {
        self._catalog = ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(_)) = self._catalog {
        } else {
            self._catalog = ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(::std::string::String::new()));
        }
        match self._catalog {
            ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_catalog(&mut self) -> ::std::string::String {
        if self.has_catalog() {
            match self._catalog.take() {
                ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string db_schema_filter_pattern = 2;


    pub fn get_db_schema_filter_pattern(&self) -> &str {
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_db_schema_filter_pattern(&mut self) {
        self._db_schema_filter_pattern = ::std::option::Option::None;
    }

    pub fn has_db_schema_filter_pattern(&self) -> bool {
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_db_schema_filter_pattern(&mut self, v: ::std::string::String) {
        self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(v))
    }

    // Mutable pointer to the field.
    pub fn mut_db_schema_filter_pattern(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(_)) = self._db_schema_filter_pattern {
        } else {
            self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(::std::string::String::new()));
        }
        match self._db_schema_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_db_schema_filter_pattern(&mut self) -> ::std::string::String {
        if self.has_db_schema_filter_pattern() {
            match self._db_schema_filter_pattern.take() {
                ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string table_name_filter_pattern = 3;


    pub fn get_table_name_filter_pattern(&self) -> &str {
        match self._table_name_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_table_name_filter_pattern(&mut self) {
        self._table_name_filter_pattern = ::std::option::Option::None;
    }

    pub fn has_table_name_filter_pattern(&self) -> bool {
        match self._table_name_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_table_name_filter_pattern(&mut self, v: ::std::string::String) {
        self._table_name_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(v))
    }

    // Mutable pointer to the field.
    pub fn mut_table_name_filter_pattern(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(_)) = self._table_name_filter_pattern {
        } else {
            self._table_name_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(::std::string::String::new()));
        }
        match self._table_name_filter_pattern {
            ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_table_name_filter_pattern(&mut self) -> ::std::string::String {
        if self.has_table_name_filter_pattern() {
            match self._table_name_filter_pattern.take() {
                ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // repeated string table_types = 4;


    pub fn get_table_types(&self) -> &[::std::string::String] {
        &self.table_types
    }
    pub fn clear_table_types(&mut self) {
        self.table_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.table_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.table_types
    }

    // Take field
    pub fn take_table_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.table_types, ::protobuf::RepeatedField::new())
    }

    // bool include_schema = 5;


    pub fn get_include_schema(&self) -> bool {
        self.include_schema
    }
    pub fn clear_include_schema(&mut self) {
        self.include_schema = false;
    }

    // Param is passed by value, moved
    pub fn set_include_schema(&mut self, v: bool) {
        self.include_schema = v;
    }
}

impl ::protobuf::Message for CommandGetTables {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._catalog = ::std::option::Option::Some(CommandGetTables_oneof__catalog::catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._db_schema_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._table_name_filter_pattern = ::std::option::Option::Some(CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.table_types)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_schema = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.table_types {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.include_schema != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetTables_oneof__catalog::catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema_filter_pattern {
            match v {
                &CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._table_name_filter_pattern {
            match v {
                &CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.table_types {
            os.write_string(4, &v)?;
        };
        if self.include_schema != false {
            os.write_bool(5, self.include_schema)?;
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetTables_oneof__catalog::catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema_filter_pattern {
            match v {
                &CommandGetTables_oneof__db_schema_filter_pattern::db_schema_filter_pattern(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._table_name_filter_pattern {
            match v {
                &CommandGetTables_oneof__table_name_filter_pattern::table_name_filter_pattern(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTables {
        CommandGetTables::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "catalog",
                CommandGetTables::has_catalog,
                CommandGetTables::get_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "db_schema_filter_pattern",
                CommandGetTables::has_db_schema_filter_pattern,
                CommandGetTables::get_db_schema_filter_pattern,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "table_name_filter_pattern",
                CommandGetTables::has_table_name_filter_pattern,
                CommandGetTables::get_table_name_filter_pattern,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_types",
                |m: &CommandGetTables| { &m.table_types },
                |m: &mut CommandGetTables| { &mut m.table_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_schema",
                |m: &CommandGetTables| { &m.include_schema },
                |m: &mut CommandGetTables| { &mut m.include_schema },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetTables>(
                "CommandGetTables",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetTables {
        static instance: ::protobuf::rt::LazyV2<CommandGetTables> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetTables::new)
    }
}

impl ::protobuf::Clear for CommandGetTables {
    fn clear(&mut self) {
        self._catalog = ::std::option::Option::None;
        self._db_schema_filter_pattern = ::std::option::Option::None;
        self._table_name_filter_pattern = ::std::option::Option::None;
        self.table_types.clear();
        self.include_schema = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTables {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetTableTypes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetTableTypes {
    fn default() -> &'a CommandGetTableTypes {
        <CommandGetTableTypes as ::protobuf::Message>::default_instance()
    }
}

impl CommandGetTableTypes {
    pub fn new() -> CommandGetTableTypes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandGetTableTypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTableTypes {
        CommandGetTableTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetTableTypes>(
                "CommandGetTableTypes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetTableTypes {
        static instance: ::protobuf::rt::LazyV2<CommandGetTableTypes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetTableTypes::new)
    }
}

impl ::protobuf::Clear for CommandGetTableTypes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetTableTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTableTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetPrimaryKeys {
    // message fields
    pub table: ::std::string::String,
    // message oneof groups
    pub _catalog: ::std::option::Option<CommandGetPrimaryKeys_oneof__catalog>,
    pub _db_schema: ::std::option::Option<CommandGetPrimaryKeys_oneof__db_schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetPrimaryKeys {
    fn default() -> &'a CommandGetPrimaryKeys {
        <CommandGetPrimaryKeys as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetPrimaryKeys_oneof__catalog {
    catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetPrimaryKeys_oneof__db_schema {
    db_schema(::std::string::String),
}

impl CommandGetPrimaryKeys {
    pub fn new() -> CommandGetPrimaryKeys {
        ::std::default::Default::default()
    }

    // string catalog = 1;


    pub fn get_catalog(&self) -> &str {
        match self._catalog {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_catalog(&mut self) {
        self._catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        match self._catalog {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: ::std::string::String) {
        self._catalog = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(_)) = self._catalog {
        } else {
            self._catalog = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(::std::string::String::new()));
        }
        match self._catalog {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_catalog(&mut self) -> ::std::string::String {
        if self.has_catalog() {
            match self._catalog.take() {
                ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string db_schema = 2;


    pub fn get_db_schema(&self) -> &str {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_db_schema(&mut self) {
        self._db_schema = ::std::option::Option::None;
    }

    pub fn has_db_schema(&self) -> bool {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_db_schema(&mut self, v: ::std::string::String) {
        self._db_schema = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(v))
    }

    // Mutable pointer to the field.
    pub fn mut_db_schema(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(_)) = self._db_schema {
        } else {
            self._db_schema = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(::std::string::String::new()));
        }
        match self._db_schema {
            ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_db_schema(&mut self) -> ::std::string::String {
        if self.has_db_schema() {
            match self._db_schema.take() {
                ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string table = 3;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandGetPrimaryKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._catalog = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__catalog::catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._db_schema = ::std::option::Option::Some(CommandGetPrimaryKeys_oneof__db_schema::db_schema(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetPrimaryKeys_oneof__catalog::catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetPrimaryKeys_oneof__db_schema::db_schema(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetPrimaryKeys_oneof__catalog::catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetPrimaryKeys_oneof__db_schema::db_schema(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetPrimaryKeys {
        CommandGetPrimaryKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "catalog",
                CommandGetPrimaryKeys::has_catalog,
                CommandGetPrimaryKeys::get_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "db_schema",
                CommandGetPrimaryKeys::has_db_schema,
                CommandGetPrimaryKeys::get_db_schema,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &CommandGetPrimaryKeys| { &m.table },
                |m: &mut CommandGetPrimaryKeys| { &mut m.table },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetPrimaryKeys>(
                "CommandGetPrimaryKeys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetPrimaryKeys {
        static instance: ::protobuf::rt::LazyV2<CommandGetPrimaryKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetPrimaryKeys::new)
    }
}

impl ::protobuf::Clear for CommandGetPrimaryKeys {
    fn clear(&mut self) {
        self._catalog = ::std::option::Option::None;
        self._db_schema = ::std::option::Option::None;
        self.table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetPrimaryKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetPrimaryKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetExportedKeys {
    // message fields
    pub table: ::std::string::String,
    // message oneof groups
    pub _catalog: ::std::option::Option<CommandGetExportedKeys_oneof__catalog>,
    pub _db_schema: ::std::option::Option<CommandGetExportedKeys_oneof__db_schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetExportedKeys {
    fn default() -> &'a CommandGetExportedKeys {
        <CommandGetExportedKeys as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetExportedKeys_oneof__catalog {
    catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetExportedKeys_oneof__db_schema {
    db_schema(::std::string::String),
}

impl CommandGetExportedKeys {
    pub fn new() -> CommandGetExportedKeys {
        ::std::default::Default::default()
    }

    // string catalog = 1;


    pub fn get_catalog(&self) -> &str {
        match self._catalog {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_catalog(&mut self) {
        self._catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        match self._catalog {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: ::std::string::String) {
        self._catalog = ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(_)) = self._catalog {
        } else {
            self._catalog = ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(::std::string::String::new()));
        }
        match self._catalog {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_catalog(&mut self) -> ::std::string::String {
        if self.has_catalog() {
            match self._catalog.take() {
                ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string db_schema = 2;


    pub fn get_db_schema(&self) -> &str {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_db_schema(&mut self) {
        self._db_schema = ::std::option::Option::None;
    }

    pub fn has_db_schema(&self) -> bool {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_db_schema(&mut self, v: ::std::string::String) {
        self._db_schema = ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(v))
    }

    // Mutable pointer to the field.
    pub fn mut_db_schema(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(_)) = self._db_schema {
        } else {
            self._db_schema = ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(::std::string::String::new()));
        }
        match self._db_schema {
            ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_db_schema(&mut self) -> ::std::string::String {
        if self.has_db_schema() {
            match self._db_schema.take() {
                ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string table = 3;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandGetExportedKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._catalog = ::std::option::Option::Some(CommandGetExportedKeys_oneof__catalog::catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._db_schema = ::std::option::Option::Some(CommandGetExportedKeys_oneof__db_schema::db_schema(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetExportedKeys_oneof__catalog::catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetExportedKeys_oneof__db_schema::db_schema(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetExportedKeys_oneof__catalog::catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetExportedKeys_oneof__db_schema::db_schema(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetExportedKeys {
        CommandGetExportedKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "catalog",
                CommandGetExportedKeys::has_catalog,
                CommandGetExportedKeys::get_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "db_schema",
                CommandGetExportedKeys::has_db_schema,
                CommandGetExportedKeys::get_db_schema,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &CommandGetExportedKeys| { &m.table },
                |m: &mut CommandGetExportedKeys| { &mut m.table },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetExportedKeys>(
                "CommandGetExportedKeys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetExportedKeys {
        static instance: ::protobuf::rt::LazyV2<CommandGetExportedKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetExportedKeys::new)
    }
}

impl ::protobuf::Clear for CommandGetExportedKeys {
    fn clear(&mut self) {
        self._catalog = ::std::option::Option::None;
        self._db_schema = ::std::option::Option::None;
        self.table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetExportedKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetExportedKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetImportedKeys {
    // message fields
    pub table: ::std::string::String,
    // message oneof groups
    pub _catalog: ::std::option::Option<CommandGetImportedKeys_oneof__catalog>,
    pub _db_schema: ::std::option::Option<CommandGetImportedKeys_oneof__db_schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetImportedKeys {
    fn default() -> &'a CommandGetImportedKeys {
        <CommandGetImportedKeys as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetImportedKeys_oneof__catalog {
    catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetImportedKeys_oneof__db_schema {
    db_schema(::std::string::String),
}

impl CommandGetImportedKeys {
    pub fn new() -> CommandGetImportedKeys {
        ::std::default::Default::default()
    }

    // string catalog = 1;


    pub fn get_catalog(&self) -> &str {
        match self._catalog {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_catalog(&mut self) {
        self._catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        match self._catalog {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: ::std::string::String) {
        self._catalog = ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(_)) = self._catalog {
        } else {
            self._catalog = ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(::std::string::String::new()));
        }
        match self._catalog {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_catalog(&mut self) -> ::std::string::String {
        if self.has_catalog() {
            match self._catalog.take() {
                ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string db_schema = 2;


    pub fn get_db_schema(&self) -> &str {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_db_schema(&mut self) {
        self._db_schema = ::std::option::Option::None;
    }

    pub fn has_db_schema(&self) -> bool {
        match self._db_schema {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_db_schema(&mut self, v: ::std::string::String) {
        self._db_schema = ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(v))
    }

    // Mutable pointer to the field.
    pub fn mut_db_schema(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(_)) = self._db_schema {
        } else {
            self._db_schema = ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(::std::string::String::new()));
        }
        match self._db_schema {
            ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_db_schema(&mut self) -> ::std::string::String {
        if self.has_db_schema() {
            match self._db_schema.take() {
                ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string table = 3;


    pub fn get_table(&self) -> &str {
        &self.table
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandGetImportedKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._catalog = ::std::option::Option::Some(CommandGetImportedKeys_oneof__catalog::catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._db_schema = ::std::option::Option::Some(CommandGetImportedKeys_oneof__db_schema::db_schema(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetImportedKeys_oneof__catalog::catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetImportedKeys_oneof__db_schema::db_schema(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if let ::std::option::Option::Some(ref v) = self._catalog {
            match v {
                &CommandGetImportedKeys_oneof__catalog::catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._db_schema {
            match v {
                &CommandGetImportedKeys_oneof__db_schema::db_schema(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetImportedKeys {
        CommandGetImportedKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "catalog",
                CommandGetImportedKeys::has_catalog,
                CommandGetImportedKeys::get_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "db_schema",
                CommandGetImportedKeys::has_db_schema,
                CommandGetImportedKeys::get_db_schema,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table",
                |m: &CommandGetImportedKeys| { &m.table },
                |m: &mut CommandGetImportedKeys| { &mut m.table },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetImportedKeys>(
                "CommandGetImportedKeys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetImportedKeys {
        static instance: ::protobuf::rt::LazyV2<CommandGetImportedKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetImportedKeys::new)
    }
}

impl ::protobuf::Clear for CommandGetImportedKeys {
    fn clear(&mut self) {
        self._catalog = ::std::option::Option::None;
        self._db_schema = ::std::option::Option::None;
        self.table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetImportedKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetImportedKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetCrossReference {
    // message fields
    pub pk_table: ::std::string::String,
    pub fk_table: ::std::string::String,
    // message oneof groups
    pub _pk_catalog: ::std::option::Option<CommandGetCrossReference_oneof__pk_catalog>,
    pub _pk_db_schema: ::std::option::Option<CommandGetCrossReference_oneof__pk_db_schema>,
    pub _fk_catalog: ::std::option::Option<CommandGetCrossReference_oneof__fk_catalog>,
    pub _fk_db_schema: ::std::option::Option<CommandGetCrossReference_oneof__fk_db_schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandGetCrossReference {
    fn default() -> &'a CommandGetCrossReference {
        <CommandGetCrossReference as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetCrossReference_oneof__pk_catalog {
    pk_catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetCrossReference_oneof__pk_db_schema {
    pk_db_schema(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetCrossReference_oneof__fk_catalog {
    fk_catalog(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum CommandGetCrossReference_oneof__fk_db_schema {
    fk_db_schema(::std::string::String),
}

impl CommandGetCrossReference {
    pub fn new() -> CommandGetCrossReference {
        ::std::default::Default::default()
    }

    // string pk_catalog = 1;


    pub fn get_pk_catalog(&self) -> &str {
        match self._pk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_pk_catalog(&mut self) {
        self._pk_catalog = ::std::option::Option::None;
    }

    pub fn has_pk_catalog(&self) -> bool {
        match self._pk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pk_catalog(&mut self, v: ::std::string::String) {
        self._pk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pk_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(_)) = self._pk_catalog {
        } else {
            self._pk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(::std::string::String::new()));
        }
        match self._pk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pk_catalog(&mut self) -> ::std::string::String {
        if self.has_pk_catalog() {
            match self._pk_catalog.take() {
                ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string pk_db_schema = 2;


    pub fn get_pk_db_schema(&self) -> &str {
        match self._pk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_pk_db_schema(&mut self) {
        self._pk_db_schema = ::std::option::Option::None;
    }

    pub fn has_pk_db_schema(&self) -> bool {
        match self._pk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pk_db_schema(&mut self, v: ::std::string::String) {
        self._pk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pk_db_schema(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(_)) = self._pk_db_schema {
        } else {
            self._pk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(::std::string::String::new()));
        }
        match self._pk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pk_db_schema(&mut self) -> ::std::string::String {
        if self.has_pk_db_schema() {
            match self._pk_db_schema.take() {
                ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string pk_table = 3;


    pub fn get_pk_table(&self) -> &str {
        &self.pk_table
    }
    pub fn clear_pk_table(&mut self) {
        self.pk_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_pk_table(&mut self, v: ::std::string::String) {
        self.pk_table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pk_table(&mut self) -> &mut ::std::string::String {
        &mut self.pk_table
    }

    // Take field
    pub fn take_pk_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pk_table, ::std::string::String::new())
    }

    // string fk_catalog = 4;


    pub fn get_fk_catalog(&self) -> &str {
        match self._fk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_fk_catalog(&mut self) {
        self._fk_catalog = ::std::option::Option::None;
    }

    pub fn has_fk_catalog(&self) -> bool {
        match self._fk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fk_catalog(&mut self, v: ::std::string::String) {
        self._fk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fk_catalog(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(_)) = self._fk_catalog {
        } else {
            self._fk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(::std::string::String::new()));
        }
        match self._fk_catalog {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fk_catalog(&mut self) -> ::std::string::String {
        if self.has_fk_catalog() {
            match self._fk_catalog.take() {
                ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string fk_db_schema = 5;


    pub fn get_fk_db_schema(&self) -> &str {
        match self._fk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_fk_db_schema(&mut self) {
        self._fk_db_schema = ::std::option::Option::None;
    }

    pub fn has_fk_db_schema(&self) -> bool {
        match self._fk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fk_db_schema(&mut self, v: ::std::string::String) {
        self._fk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fk_db_schema(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(_)) = self._fk_db_schema {
        } else {
            self._fk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(::std::string::String::new()));
        }
        match self._fk_db_schema {
            ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fk_db_schema(&mut self) -> ::std::string::String {
        if self.has_fk_db_schema() {
            match self._fk_db_schema.take() {
                ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string fk_table = 6;


    pub fn get_fk_table(&self) -> &str {
        &self.fk_table
    }
    pub fn clear_fk_table(&mut self) {
        self.fk_table.clear();
    }

    // Param is passed by value, moved
    pub fn set_fk_table(&mut self, v: ::std::string::String) {
        self.fk_table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fk_table(&mut self) -> &mut ::std::string::String {
        &mut self.fk_table
    }

    // Take field
    pub fn take_fk_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fk_table, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandGetCrossReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._pk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_catalog::pk_catalog(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._pk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pk_table)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._fk_catalog = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_catalog::fk_catalog(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._fk_db_schema = ::std::option::Option::Some(CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(is.read_string()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fk_table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pk_table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.pk_table);
        }
        if !self.fk_table.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.fk_table);
        }
        if let ::std::option::Option::Some(ref v) = self._pk_catalog {
            match v {
                &CommandGetCrossReference_oneof__pk_catalog::pk_catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._pk_db_schema {
            match v {
                &CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._fk_catalog {
            match v {
                &CommandGetCrossReference_oneof__fk_catalog::fk_catalog(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._fk_db_schema {
            match v {
                &CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pk_table.is_empty() {
            os.write_string(3, &self.pk_table)?;
        }
        if !self.fk_table.is_empty() {
            os.write_string(6, &self.fk_table)?;
        }
        if let ::std::option::Option::Some(ref v) = self._pk_catalog {
            match v {
                &CommandGetCrossReference_oneof__pk_catalog::pk_catalog(ref v) => {
                    os.write_string(1, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._pk_db_schema {
            match v {
                &CommandGetCrossReference_oneof__pk_db_schema::pk_db_schema(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._fk_catalog {
            match v {
                &CommandGetCrossReference_oneof__fk_catalog::fk_catalog(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._fk_db_schema {
            match v {
                &CommandGetCrossReference_oneof__fk_db_schema::fk_db_schema(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetCrossReference {
        CommandGetCrossReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "pk_catalog",
                CommandGetCrossReference::has_pk_catalog,
                CommandGetCrossReference::get_pk_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "pk_db_schema",
                CommandGetCrossReference::has_pk_db_schema,
                CommandGetCrossReference::get_pk_db_schema,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pk_table",
                |m: &CommandGetCrossReference| { &m.pk_table },
                |m: &mut CommandGetCrossReference| { &mut m.pk_table },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "fk_catalog",
                CommandGetCrossReference::has_fk_catalog,
                CommandGetCrossReference::get_fk_catalog,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "fk_db_schema",
                CommandGetCrossReference::has_fk_db_schema,
                CommandGetCrossReference::get_fk_db_schema,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fk_table",
                |m: &CommandGetCrossReference| { &m.fk_table },
                |m: &mut CommandGetCrossReference| { &mut m.fk_table },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandGetCrossReference>(
                "CommandGetCrossReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandGetCrossReference {
        static instance: ::protobuf::rt::LazyV2<CommandGetCrossReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandGetCrossReference::new)
    }
}

impl ::protobuf::Clear for CommandGetCrossReference {
    fn clear(&mut self) {
        self._pk_catalog = ::std::option::Option::None;
        self._pk_db_schema = ::std::option::Option::None;
        self.pk_table.clear();
        self._fk_catalog = ::std::option::Option::None;
        self._fk_db_schema = ::std::option::Option::None;
        self.fk_table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetCrossReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetCrossReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionCreatePreparedStatementRequest {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionCreatePreparedStatementRequest {
    fn default() -> &'a ActionCreatePreparedStatementRequest {
        <ActionCreatePreparedStatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActionCreatePreparedStatementRequest {
    pub fn new() -> ActionCreatePreparedStatementRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActionCreatePreparedStatementRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionCreatePreparedStatementRequest {
        ActionCreatePreparedStatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &ActionCreatePreparedStatementRequest| { &m.query },
                |m: &mut ActionCreatePreparedStatementRequest| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionCreatePreparedStatementRequest>(
                "ActionCreatePreparedStatementRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionCreatePreparedStatementRequest {
        static instance: ::protobuf::rt::LazyV2<ActionCreatePreparedStatementRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionCreatePreparedStatementRequest::new)
    }
}

impl ::protobuf::Clear for ActionCreatePreparedStatementRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionCreatePreparedStatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCreatePreparedStatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionCreatePreparedStatementResult {
    // message fields
    pub prepared_statement_handle: ::std::vec::Vec<u8>,
    pub dataset_schema: ::std::vec::Vec<u8>,
    pub parameter_schema: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionCreatePreparedStatementResult {
    fn default() -> &'a ActionCreatePreparedStatementResult {
        <ActionCreatePreparedStatementResult as ::protobuf::Message>::default_instance()
    }
}

impl ActionCreatePreparedStatementResult {
    pub fn new() -> ActionCreatePreparedStatementResult {
        ::std::default::Default::default()
    }

    // bytes prepared_statement_handle = 1;


    pub fn get_prepared_statement_handle(&self) -> &[u8] {
        &self.prepared_statement_handle
    }
    pub fn clear_prepared_statement_handle(&mut self) {
        self.prepared_statement_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_statement_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_statement_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_statement_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_statement_handle
    }

    // Take field
    pub fn take_prepared_statement_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_statement_handle, ::std::vec::Vec::new())
    }

    // bytes dataset_schema = 2;


    pub fn get_dataset_schema(&self) -> &[u8] {
        &self.dataset_schema
    }
    pub fn clear_dataset_schema(&mut self) {
        self.dataset_schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.dataset_schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_schema(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dataset_schema
    }

    // Take field
    pub fn take_dataset_schema(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dataset_schema, ::std::vec::Vec::new())
    }

    // bytes parameter_schema = 3;


    pub fn get_parameter_schema(&self) -> &[u8] {
        &self.parameter_schema
    }
    pub fn clear_parameter_schema(&mut self) {
        self.parameter_schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.parameter_schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter_schema(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parameter_schema
    }

    // Take field
    pub fn take_parameter_schema(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parameter_schema, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActionCreatePreparedStatementResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prepared_statement_handle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dataset_schema)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parameter_schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prepared_statement_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prepared_statement_handle);
        }
        if !self.dataset_schema.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.dataset_schema);
        }
        if !self.parameter_schema.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parameter_schema);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prepared_statement_handle.is_empty() {
            os.write_bytes(1, &self.prepared_statement_handle)?;
        }
        if !self.dataset_schema.is_empty() {
            os.write_bytes(2, &self.dataset_schema)?;
        }
        if !self.parameter_schema.is_empty() {
            os.write_bytes(3, &self.parameter_schema)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionCreatePreparedStatementResult {
        ActionCreatePreparedStatementResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prepared_statement_handle",
                |m: &ActionCreatePreparedStatementResult| { &m.prepared_statement_handle },
                |m: &mut ActionCreatePreparedStatementResult| { &mut m.prepared_statement_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dataset_schema",
                |m: &ActionCreatePreparedStatementResult| { &m.dataset_schema },
                |m: &mut ActionCreatePreparedStatementResult| { &mut m.dataset_schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parameter_schema",
                |m: &ActionCreatePreparedStatementResult| { &m.parameter_schema },
                |m: &mut ActionCreatePreparedStatementResult| { &mut m.parameter_schema },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionCreatePreparedStatementResult>(
                "ActionCreatePreparedStatementResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionCreatePreparedStatementResult {
        static instance: ::protobuf::rt::LazyV2<ActionCreatePreparedStatementResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionCreatePreparedStatementResult::new)
    }
}

impl ::protobuf::Clear for ActionCreatePreparedStatementResult {
    fn clear(&mut self) {
        self.prepared_statement_handle.clear();
        self.dataset_schema.clear();
        self.parameter_schema.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionCreatePreparedStatementResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCreatePreparedStatementResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionClosePreparedStatementRequest {
    // message fields
    pub prepared_statement_handle: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActionClosePreparedStatementRequest {
    fn default() -> &'a ActionClosePreparedStatementRequest {
        <ActionClosePreparedStatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActionClosePreparedStatementRequest {
    pub fn new() -> ActionClosePreparedStatementRequest {
        ::std::default::Default::default()
    }

    // bytes prepared_statement_handle = 1;


    pub fn get_prepared_statement_handle(&self) -> &[u8] {
        &self.prepared_statement_handle
    }
    pub fn clear_prepared_statement_handle(&mut self) {
        self.prepared_statement_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_statement_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_statement_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_statement_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_statement_handle
    }

    // Take field
    pub fn take_prepared_statement_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_statement_handle, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActionClosePreparedStatementRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prepared_statement_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prepared_statement_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prepared_statement_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prepared_statement_handle.is_empty() {
            os.write_bytes(1, &self.prepared_statement_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionClosePreparedStatementRequest {
        ActionClosePreparedStatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prepared_statement_handle",
                |m: &ActionClosePreparedStatementRequest| { &m.prepared_statement_handle },
                |m: &mut ActionClosePreparedStatementRequest| { &mut m.prepared_statement_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActionClosePreparedStatementRequest>(
                "ActionClosePreparedStatementRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActionClosePreparedStatementRequest {
        static instance: ::protobuf::rt::LazyV2<ActionClosePreparedStatementRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActionClosePreparedStatementRequest::new)
    }
}

impl ::protobuf::Clear for ActionClosePreparedStatementRequest {
    fn clear(&mut self) {
        self.prepared_statement_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionClosePreparedStatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionClosePreparedStatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandStatementQuery {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandStatementQuery {
    fn default() -> &'a CommandStatementQuery {
        <CommandStatementQuery as ::protobuf::Message>::default_instance()
    }
}

impl CommandStatementQuery {
    pub fn new() -> CommandStatementQuery {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandStatementQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandStatementQuery {
        CommandStatementQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &CommandStatementQuery| { &m.query },
                |m: &mut CommandStatementQuery| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandStatementQuery>(
                "CommandStatementQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandStatementQuery {
        static instance: ::protobuf::rt::LazyV2<CommandStatementQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandStatementQuery::new)
    }
}

impl ::protobuf::Clear for CommandStatementQuery {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandStatementQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandStatementQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TicketStatementQuery {
    // message fields
    pub statement_handle: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TicketStatementQuery {
    fn default() -> &'a TicketStatementQuery {
        <TicketStatementQuery as ::protobuf::Message>::default_instance()
    }
}

impl TicketStatementQuery {
    pub fn new() -> TicketStatementQuery {
        ::std::default::Default::default()
    }

    // bytes statement_handle = 1;


    pub fn get_statement_handle(&self) -> &[u8] {
        &self.statement_handle
    }
    pub fn clear_statement_handle(&mut self) {
        self.statement_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_statement_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.statement_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.statement_handle
    }

    // Take field
    pub fn take_statement_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.statement_handle, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TicketStatementQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.statement_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.statement_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.statement_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.statement_handle.is_empty() {
            os.write_bytes(1, &self.statement_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TicketStatementQuery {
        TicketStatementQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "statement_handle",
                |m: &TicketStatementQuery| { &m.statement_handle },
                |m: &mut TicketStatementQuery| { &mut m.statement_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TicketStatementQuery>(
                "TicketStatementQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TicketStatementQuery {
        static instance: ::protobuf::rt::LazyV2<TicketStatementQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TicketStatementQuery::new)
    }
}

impl ::protobuf::Clear for TicketStatementQuery {
    fn clear(&mut self) {
        self.statement_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TicketStatementQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TicketStatementQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPreparedStatementQuery {
    // message fields
    pub prepared_statement_handle: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPreparedStatementQuery {
    fn default() -> &'a CommandPreparedStatementQuery {
        <CommandPreparedStatementQuery as ::protobuf::Message>::default_instance()
    }
}

impl CommandPreparedStatementQuery {
    pub fn new() -> CommandPreparedStatementQuery {
        ::std::default::Default::default()
    }

    // bytes prepared_statement_handle = 1;


    pub fn get_prepared_statement_handle(&self) -> &[u8] {
        &self.prepared_statement_handle
    }
    pub fn clear_prepared_statement_handle(&mut self) {
        self.prepared_statement_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_statement_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_statement_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_statement_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_statement_handle
    }

    // Take field
    pub fn take_prepared_statement_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_statement_handle, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandPreparedStatementQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prepared_statement_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prepared_statement_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prepared_statement_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prepared_statement_handle.is_empty() {
            os.write_bytes(1, &self.prepared_statement_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPreparedStatementQuery {
        CommandPreparedStatementQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prepared_statement_handle",
                |m: &CommandPreparedStatementQuery| { &m.prepared_statement_handle },
                |m: &mut CommandPreparedStatementQuery| { &mut m.prepared_statement_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandPreparedStatementQuery>(
                "CommandPreparedStatementQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandPreparedStatementQuery {
        static instance: ::protobuf::rt::LazyV2<CommandPreparedStatementQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPreparedStatementQuery::new)
    }
}

impl ::protobuf::Clear for CommandPreparedStatementQuery {
    fn clear(&mut self) {
        self.prepared_statement_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPreparedStatementQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPreparedStatementQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandStatementUpdate {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandStatementUpdate {
    fn default() -> &'a CommandStatementUpdate {
        <CommandStatementUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CommandStatementUpdate {
    pub fn new() -> CommandStatementUpdate {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommandStatementUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandStatementUpdate {
        CommandStatementUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &CommandStatementUpdate| { &m.query },
                |m: &mut CommandStatementUpdate| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandStatementUpdate>(
                "CommandStatementUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandStatementUpdate {
        static instance: ::protobuf::rt::LazyV2<CommandStatementUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandStatementUpdate::new)
    }
}

impl ::protobuf::Clear for CommandStatementUpdate {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandStatementUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandStatementUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPreparedStatementUpdate {
    // message fields
    pub prepared_statement_handle: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommandPreparedStatementUpdate {
    fn default() -> &'a CommandPreparedStatementUpdate {
        <CommandPreparedStatementUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CommandPreparedStatementUpdate {
    pub fn new() -> CommandPreparedStatementUpdate {
        ::std::default::Default::default()
    }

    // bytes prepared_statement_handle = 1;


    pub fn get_prepared_statement_handle(&self) -> &[u8] {
        &self.prepared_statement_handle
    }
    pub fn clear_prepared_statement_handle(&mut self) {
        self.prepared_statement_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_prepared_statement_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.prepared_statement_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prepared_statement_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prepared_statement_handle
    }

    // Take field
    pub fn take_prepared_statement_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prepared_statement_handle, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommandPreparedStatementUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prepared_statement_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prepared_statement_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prepared_statement_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prepared_statement_handle.is_empty() {
            os.write_bytes(1, &self.prepared_statement_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPreparedStatementUpdate {
        CommandPreparedStatementUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prepared_statement_handle",
                |m: &CommandPreparedStatementUpdate| { &m.prepared_statement_handle },
                |m: &mut CommandPreparedStatementUpdate| { &mut m.prepared_statement_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommandPreparedStatementUpdate>(
                "CommandPreparedStatementUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommandPreparedStatementUpdate {
        static instance: ::protobuf::rt::LazyV2<CommandPreparedStatementUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommandPreparedStatementUpdate::new)
    }
}

impl ::protobuf::Clear for CommandPreparedStatementUpdate {
    fn clear(&mut self) {
        self.prepared_statement_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPreparedStatementUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPreparedStatementUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DoPutUpdateResult {
    // message fields
    pub record_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DoPutUpdateResult {
    fn default() -> &'a DoPutUpdateResult {
        <DoPutUpdateResult as ::protobuf::Message>::default_instance()
    }
}

impl DoPutUpdateResult {
    pub fn new() -> DoPutUpdateResult {
        ::std::default::Default::default()
    }

    // int64 record_count = 1;


    pub fn get_record_count(&self) -> i64 {
        self.record_count
    }
    pub fn clear_record_count(&mut self) {
        self.record_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_record_count(&mut self, v: i64) {
        self.record_count = v;
    }
}

impl ::protobuf::Message for DoPutUpdateResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.record_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.record_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.record_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.record_count != 0 {
            os.write_int64(1, self.record_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DoPutUpdateResult {
        DoPutUpdateResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "record_count",
                |m: &DoPutUpdateResult| { &m.record_count },
                |m: &mut DoPutUpdateResult| { &mut m.record_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DoPutUpdateResult>(
                "DoPutUpdateResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DoPutUpdateResult {
        static instance: ::protobuf::rt::LazyV2<DoPutUpdateResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DoPutUpdateResult::new)
    }
}

impl ::protobuf::Clear for DoPutUpdateResult {
    fn clear(&mut self) {
        self.record_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DoPutUpdateResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoPutUpdateResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlInfo {
    FLIGHT_SQL_SERVER_NAME = 0,
    FLIGHT_SQL_SERVER_VERSION = 1,
    FLIGHT_SQL_SERVER_ARROW_VERSION = 2,
    FLIGHT_SQL_SERVER_READ_ONLY = 3,
    SQL_DDL_CATALOG = 500,
    SQL_DDL_SCHEMA = 501,
    SQL_DDL_TABLE = 502,
    SQL_IDENTIFIER_CASE = 503,
    SQL_IDENTIFIER_QUOTE_CHAR = 504,
    SQL_QUOTED_IDENTIFIER_CASE = 505,
    SQL_ALL_TABLES_ARE_SELECTABLE = 506,
    SQL_NULL_ORDERING = 507,
    SQL_KEYWORDS = 508,
    SQL_NUMERIC_FUNCTIONS = 509,
    SQL_STRING_FUNCTIONS = 510,
    SQL_SYSTEM_FUNCTIONS = 511,
    SQL_DATETIME_FUNCTIONS = 512,
    SQL_SEARCH_STRING_ESCAPE = 513,
    SQL_EXTRA_NAME_CHARACTERS = 514,
    SQL_SUPPORTS_COLUMN_ALIASING = 515,
    SQL_NULL_PLUS_NULL_IS_NULL = 516,
    SQL_SUPPORTS_CONVERT = 517,
    SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518,
    SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519,
    SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520,
    SQL_SUPPORTS_ORDER_BY_UNRELATED = 521,
    SQL_SUPPORTED_GROUP_BY = 522,
    SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523,
    SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524,
    SQL_SUPPORTED_GRAMMAR = 525,
    SQL_ANSI92_SUPPORTED_LEVEL = 526,
    SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527,
    SQL_OUTER_JOINS_SUPPORT_LEVEL = 528,
    SQL_SCHEMA_TERM = 529,
    SQL_PROCEDURE_TERM = 530,
    SQL_CATALOG_TERM = 531,
    SQL_CATALOG_AT_START = 532,
    SQL_SCHEMAS_SUPPORTED_ACTIONS = 533,
    SQL_CATALOGS_SUPPORTED_ACTIONS = 534,
    SQL_SUPPORTED_POSITIONED_COMMANDS = 535,
    SQL_SELECT_FOR_UPDATE_SUPPORTED = 536,
    SQL_STORED_PROCEDURES_SUPPORTED = 537,
    SQL_SUPPORTED_SUBQUERIES = 538,
    SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539,
    SQL_SUPPORTED_UNIONS = 540,
    SQL_MAX_BINARY_LITERAL_LENGTH = 541,
    SQL_MAX_CHAR_LITERAL_LENGTH = 542,
    SQL_MAX_COLUMN_NAME_LENGTH = 543,
    SQL_MAX_COLUMNS_IN_GROUP_BY = 544,
    SQL_MAX_COLUMNS_IN_INDEX = 545,
    SQL_MAX_COLUMNS_IN_ORDER_BY = 546,
    SQL_MAX_COLUMNS_IN_SELECT = 547,
    SQL_MAX_COLUMNS_IN_TABLE = 548,
    SQL_MAX_CONNECTIONS = 549,
    SQL_MAX_CURSOR_NAME_LENGTH = 550,
    SQL_MAX_INDEX_LENGTH = 551,
    SQL_DB_SCHEMA_NAME_LENGTH = 552,
    SQL_MAX_PROCEDURE_NAME_LENGTH = 553,
    SQL_MAX_CATALOG_NAME_LENGTH = 554,
    SQL_MAX_ROW_SIZE = 555,
    SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556,
    SQL_MAX_STATEMENT_LENGTH = 557,
    SQL_MAX_STATEMENTS = 558,
    SQL_MAX_TABLE_NAME_LENGTH = 559,
    SQL_MAX_TABLES_IN_SELECT = 560,
    SQL_MAX_USERNAME_LENGTH = 561,
    SQL_DEFAULT_TRANSACTION_ISOLATION = 562,
    SQL_TRANSACTIONS_SUPPORTED = 563,
    SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564,
    SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565,
    SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566,
    SQL_SUPPORTED_RESULT_SET_TYPES = 567,
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568,
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569,
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570,
    SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571,
    SQL_BATCH_UPDATES_SUPPORTED = 572,
    SQL_SAVEPOINTS_SUPPORTED = 573,
    SQL_NAMED_PARAMETERS_SUPPORTED = 574,
    SQL_LOCATORS_UPDATE_COPY = 575,
    SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576,
}

impl ::protobuf::ProtobufEnum for SqlInfo {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlInfo> {
        match value {
            0 => ::std::option::Option::Some(SqlInfo::FLIGHT_SQL_SERVER_NAME),
            1 => ::std::option::Option::Some(SqlInfo::FLIGHT_SQL_SERVER_VERSION),
            2 => ::std::option::Option::Some(SqlInfo::FLIGHT_SQL_SERVER_ARROW_VERSION),
            3 => ::std::option::Option::Some(SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY),
            500 => ::std::option::Option::Some(SqlInfo::SQL_DDL_CATALOG),
            501 => ::std::option::Option::Some(SqlInfo::SQL_DDL_SCHEMA),
            502 => ::std::option::Option::Some(SqlInfo::SQL_DDL_TABLE),
            503 => ::std::option::Option::Some(SqlInfo::SQL_IDENTIFIER_CASE),
            504 => ::std::option::Option::Some(SqlInfo::SQL_IDENTIFIER_QUOTE_CHAR),
            505 => ::std::option::Option::Some(SqlInfo::SQL_QUOTED_IDENTIFIER_CASE),
            506 => ::std::option::Option::Some(SqlInfo::SQL_ALL_TABLES_ARE_SELECTABLE),
            507 => ::std::option::Option::Some(SqlInfo::SQL_NULL_ORDERING),
            508 => ::std::option::Option::Some(SqlInfo::SQL_KEYWORDS),
            509 => ::std::option::Option::Some(SqlInfo::SQL_NUMERIC_FUNCTIONS),
            510 => ::std::option::Option::Some(SqlInfo::SQL_STRING_FUNCTIONS),
            511 => ::std::option::Option::Some(SqlInfo::SQL_SYSTEM_FUNCTIONS),
            512 => ::std::option::Option::Some(SqlInfo::SQL_DATETIME_FUNCTIONS),
            513 => ::std::option::Option::Some(SqlInfo::SQL_SEARCH_STRING_ESCAPE),
            514 => ::std::option::Option::Some(SqlInfo::SQL_EXTRA_NAME_CHARACTERS),
            515 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_COLUMN_ALIASING),
            516 => ::std::option::Option::Some(SqlInfo::SQL_NULL_PLUS_NULL_IS_NULL),
            517 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_CONVERT),
            518 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_TABLE_CORRELATION_NAMES),
            519 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES),
            520 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY),
            521 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_ORDER_BY_UNRELATED),
            522 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_GROUP_BY),
            523 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE),
            524 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_NON_NULLABLE_COLUMNS),
            525 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_GRAMMAR),
            526 => ::std::option::Option::Some(SqlInfo::SQL_ANSI92_SUPPORTED_LEVEL),
            527 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY),
            528 => ::std::option::Option::Some(SqlInfo::SQL_OUTER_JOINS_SUPPORT_LEVEL),
            529 => ::std::option::Option::Some(SqlInfo::SQL_SCHEMA_TERM),
            530 => ::std::option::Option::Some(SqlInfo::SQL_PROCEDURE_TERM),
            531 => ::std::option::Option::Some(SqlInfo::SQL_CATALOG_TERM),
            532 => ::std::option::Option::Some(SqlInfo::SQL_CATALOG_AT_START),
            533 => ::std::option::Option::Some(SqlInfo::SQL_SCHEMAS_SUPPORTED_ACTIONS),
            534 => ::std::option::Option::Some(SqlInfo::SQL_CATALOGS_SUPPORTED_ACTIONS),
            535 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_POSITIONED_COMMANDS),
            536 => ::std::option::Option::Some(SqlInfo::SQL_SELECT_FOR_UPDATE_SUPPORTED),
            537 => ::std::option::Option::Some(SqlInfo::SQL_STORED_PROCEDURES_SUPPORTED),
            538 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_SUBQUERIES),
            539 => ::std::option::Option::Some(SqlInfo::SQL_CORRELATED_SUBQUERIES_SUPPORTED),
            540 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_UNIONS),
            541 => ::std::option::Option::Some(SqlInfo::SQL_MAX_BINARY_LITERAL_LENGTH),
            542 => ::std::option::Option::Some(SqlInfo::SQL_MAX_CHAR_LITERAL_LENGTH),
            543 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMN_NAME_LENGTH),
            544 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMNS_IN_GROUP_BY),
            545 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMNS_IN_INDEX),
            546 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMNS_IN_ORDER_BY),
            547 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMNS_IN_SELECT),
            548 => ::std::option::Option::Some(SqlInfo::SQL_MAX_COLUMNS_IN_TABLE),
            549 => ::std::option::Option::Some(SqlInfo::SQL_MAX_CONNECTIONS),
            550 => ::std::option::Option::Some(SqlInfo::SQL_MAX_CURSOR_NAME_LENGTH),
            551 => ::std::option::Option::Some(SqlInfo::SQL_MAX_INDEX_LENGTH),
            552 => ::std::option::Option::Some(SqlInfo::SQL_DB_SCHEMA_NAME_LENGTH),
            553 => ::std::option::Option::Some(SqlInfo::SQL_MAX_PROCEDURE_NAME_LENGTH),
            554 => ::std::option::Option::Some(SqlInfo::SQL_MAX_CATALOG_NAME_LENGTH),
            555 => ::std::option::Option::Some(SqlInfo::SQL_MAX_ROW_SIZE),
            556 => ::std::option::Option::Some(SqlInfo::SQL_MAX_ROW_SIZE_INCLUDES_BLOBS),
            557 => ::std::option::Option::Some(SqlInfo::SQL_MAX_STATEMENT_LENGTH),
            558 => ::std::option::Option::Some(SqlInfo::SQL_MAX_STATEMENTS),
            559 => ::std::option::Option::Some(SqlInfo::SQL_MAX_TABLE_NAME_LENGTH),
            560 => ::std::option::Option::Some(SqlInfo::SQL_MAX_TABLES_IN_SELECT),
            561 => ::std::option::Option::Some(SqlInfo::SQL_MAX_USERNAME_LENGTH),
            562 => ::std::option::Option::Some(SqlInfo::SQL_DEFAULT_TRANSACTION_ISOLATION),
            563 => ::std::option::Option::Some(SqlInfo::SQL_TRANSACTIONS_SUPPORTED),
            564 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS),
            565 => ::std::option::Option::Some(SqlInfo::SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT),
            566 => ::std::option::Option::Some(SqlInfo::SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED),
            567 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_RESULT_SET_TYPES),
            568 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED),
            569 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY),
            570 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE),
            571 => ::std::option::Option::Some(SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE),
            572 => ::std::option::Option::Some(SqlInfo::SQL_BATCH_UPDATES_SUPPORTED),
            573 => ::std::option::Option::Some(SqlInfo::SQL_SAVEPOINTS_SUPPORTED),
            574 => ::std::option::Option::Some(SqlInfo::SQL_NAMED_PARAMETERS_SUPPORTED),
            575 => ::std::option::Option::Some(SqlInfo::SQL_LOCATORS_UPDATE_COPY),
            576 => ::std::option::Option::Some(SqlInfo::SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlInfo] = &[
            SqlInfo::FLIGHT_SQL_SERVER_NAME,
            SqlInfo::FLIGHT_SQL_SERVER_VERSION,
            SqlInfo::FLIGHT_SQL_SERVER_ARROW_VERSION,
            SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY,
            SqlInfo::SQL_DDL_CATALOG,
            SqlInfo::SQL_DDL_SCHEMA,
            SqlInfo::SQL_DDL_TABLE,
            SqlInfo::SQL_IDENTIFIER_CASE,
            SqlInfo::SQL_IDENTIFIER_QUOTE_CHAR,
            SqlInfo::SQL_QUOTED_IDENTIFIER_CASE,
            SqlInfo::SQL_ALL_TABLES_ARE_SELECTABLE,
            SqlInfo::SQL_NULL_ORDERING,
            SqlInfo::SQL_KEYWORDS,
            SqlInfo::SQL_NUMERIC_FUNCTIONS,
            SqlInfo::SQL_STRING_FUNCTIONS,
            SqlInfo::SQL_SYSTEM_FUNCTIONS,
            SqlInfo::SQL_DATETIME_FUNCTIONS,
            SqlInfo::SQL_SEARCH_STRING_ESCAPE,
            SqlInfo::SQL_EXTRA_NAME_CHARACTERS,
            SqlInfo::SQL_SUPPORTS_COLUMN_ALIASING,
            SqlInfo::SQL_NULL_PLUS_NULL_IS_NULL,
            SqlInfo::SQL_SUPPORTS_CONVERT,
            SqlInfo::SQL_SUPPORTS_TABLE_CORRELATION_NAMES,
            SqlInfo::SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES,
            SqlInfo::SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY,
            SqlInfo::SQL_SUPPORTS_ORDER_BY_UNRELATED,
            SqlInfo::SQL_SUPPORTED_GROUP_BY,
            SqlInfo::SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE,
            SqlInfo::SQL_SUPPORTS_NON_NULLABLE_COLUMNS,
            SqlInfo::SQL_SUPPORTED_GRAMMAR,
            SqlInfo::SQL_ANSI92_SUPPORTED_LEVEL,
            SqlInfo::SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY,
            SqlInfo::SQL_OUTER_JOINS_SUPPORT_LEVEL,
            SqlInfo::SQL_SCHEMA_TERM,
            SqlInfo::SQL_PROCEDURE_TERM,
            SqlInfo::SQL_CATALOG_TERM,
            SqlInfo::SQL_CATALOG_AT_START,
            SqlInfo::SQL_SCHEMAS_SUPPORTED_ACTIONS,
            SqlInfo::SQL_CATALOGS_SUPPORTED_ACTIONS,
            SqlInfo::SQL_SUPPORTED_POSITIONED_COMMANDS,
            SqlInfo::SQL_SELECT_FOR_UPDATE_SUPPORTED,
            SqlInfo::SQL_STORED_PROCEDURES_SUPPORTED,
            SqlInfo::SQL_SUPPORTED_SUBQUERIES,
            SqlInfo::SQL_CORRELATED_SUBQUERIES_SUPPORTED,
            SqlInfo::SQL_SUPPORTED_UNIONS,
            SqlInfo::SQL_MAX_BINARY_LITERAL_LENGTH,
            SqlInfo::SQL_MAX_CHAR_LITERAL_LENGTH,
            SqlInfo::SQL_MAX_COLUMN_NAME_LENGTH,
            SqlInfo::SQL_MAX_COLUMNS_IN_GROUP_BY,
            SqlInfo::SQL_MAX_COLUMNS_IN_INDEX,
            SqlInfo::SQL_MAX_COLUMNS_IN_ORDER_BY,
            SqlInfo::SQL_MAX_COLUMNS_IN_SELECT,
            SqlInfo::SQL_MAX_COLUMNS_IN_TABLE,
            SqlInfo::SQL_MAX_CONNECTIONS,
            SqlInfo::SQL_MAX_CURSOR_NAME_LENGTH,
            SqlInfo::SQL_MAX_INDEX_LENGTH,
            SqlInfo::SQL_DB_SCHEMA_NAME_LENGTH,
            SqlInfo::SQL_MAX_PROCEDURE_NAME_LENGTH,
            SqlInfo::SQL_MAX_CATALOG_NAME_LENGTH,
            SqlInfo::SQL_MAX_ROW_SIZE,
            SqlInfo::SQL_MAX_ROW_SIZE_INCLUDES_BLOBS,
            SqlInfo::SQL_MAX_STATEMENT_LENGTH,
            SqlInfo::SQL_MAX_STATEMENTS,
            SqlInfo::SQL_MAX_TABLE_NAME_LENGTH,
            SqlInfo::SQL_MAX_TABLES_IN_SELECT,
            SqlInfo::SQL_MAX_USERNAME_LENGTH,
            SqlInfo::SQL_DEFAULT_TRANSACTION_ISOLATION,
            SqlInfo::SQL_TRANSACTIONS_SUPPORTED,
            SqlInfo::SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS,
            SqlInfo::SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT,
            SqlInfo::SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED,
            SqlInfo::SQL_SUPPORTED_RESULT_SET_TYPES,
            SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED,
            SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY,
            SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE,
            SqlInfo::SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE,
            SqlInfo::SQL_BATCH_UPDATES_SUPPORTED,
            SqlInfo::SQL_SAVEPOINTS_SUPPORTED,
            SqlInfo::SQL_NAMED_PARAMETERS_SUPPORTED,
            SqlInfo::SQL_LOCATORS_UPDATE_COPY,
            SqlInfo::SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlInfo>("SqlInfo", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlInfo {
}

impl ::std::default::Default for SqlInfo {
    fn default() -> Self {
        SqlInfo::FLIGHT_SQL_SERVER_NAME
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedCaseSensitivity {
    SQL_CASE_SENSITIVITY_UNKNOWN = 0,
    SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1,
    SQL_CASE_SENSITIVITY_UPPERCASE = 2,
    SQL_CASE_SENSITIVITY_LOWERCASE = 3,
}

impl ::protobuf::ProtobufEnum for SqlSupportedCaseSensitivity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedCaseSensitivity> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_UNKNOWN),
            1 => ::std::option::Option::Some(SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_CASE_INSENSITIVE),
            2 => ::std::option::Option::Some(SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_UPPERCASE),
            3 => ::std::option::Option::Some(SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_LOWERCASE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedCaseSensitivity] = &[
            SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_UNKNOWN,
            SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_CASE_INSENSITIVE,
            SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_UPPERCASE,
            SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_LOWERCASE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedCaseSensitivity>("SqlSupportedCaseSensitivity", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedCaseSensitivity {
}

impl ::std::default::Default for SqlSupportedCaseSensitivity {
    fn default() -> Self {
        SqlSupportedCaseSensitivity::SQL_CASE_SENSITIVITY_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedCaseSensitivity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlNullOrdering {
    SQL_NULLS_SORTED_HIGH = 0,
    SQL_NULLS_SORTED_LOW = 1,
    SQL_NULLS_SORTED_AT_START = 2,
    SQL_NULLS_SORTED_AT_END = 3,
}

impl ::protobuf::ProtobufEnum for SqlNullOrdering {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlNullOrdering> {
        match value {
            0 => ::std::option::Option::Some(SqlNullOrdering::SQL_NULLS_SORTED_HIGH),
            1 => ::std::option::Option::Some(SqlNullOrdering::SQL_NULLS_SORTED_LOW),
            2 => ::std::option::Option::Some(SqlNullOrdering::SQL_NULLS_SORTED_AT_START),
            3 => ::std::option::Option::Some(SqlNullOrdering::SQL_NULLS_SORTED_AT_END),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlNullOrdering] = &[
            SqlNullOrdering::SQL_NULLS_SORTED_HIGH,
            SqlNullOrdering::SQL_NULLS_SORTED_LOW,
            SqlNullOrdering::SQL_NULLS_SORTED_AT_START,
            SqlNullOrdering::SQL_NULLS_SORTED_AT_END,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlNullOrdering>("SqlNullOrdering", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlNullOrdering {
}

impl ::std::default::Default for SqlNullOrdering {
    fn default() -> Self {
        SqlNullOrdering::SQL_NULLS_SORTED_HIGH
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlNullOrdering {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupportedSqlGrammar {
    SQL_MINIMUM_GRAMMAR = 0,
    SQL_CORE_GRAMMAR = 1,
    SQL_EXTENDED_GRAMMAR = 2,
}

impl ::protobuf::ProtobufEnum for SupportedSqlGrammar {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupportedSqlGrammar> {
        match value {
            0 => ::std::option::Option::Some(SupportedSqlGrammar::SQL_MINIMUM_GRAMMAR),
            1 => ::std::option::Option::Some(SupportedSqlGrammar::SQL_CORE_GRAMMAR),
            2 => ::std::option::Option::Some(SupportedSqlGrammar::SQL_EXTENDED_GRAMMAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupportedSqlGrammar] = &[
            SupportedSqlGrammar::SQL_MINIMUM_GRAMMAR,
            SupportedSqlGrammar::SQL_CORE_GRAMMAR,
            SupportedSqlGrammar::SQL_EXTENDED_GRAMMAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SupportedSqlGrammar>("SupportedSqlGrammar", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SupportedSqlGrammar {
}

impl ::std::default::Default for SupportedSqlGrammar {
    fn default() -> Self {
        SupportedSqlGrammar::SQL_MINIMUM_GRAMMAR
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedSqlGrammar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupportedAnsi92SqlGrammarLevel {
    ANSI92_ENTRY_SQL = 0,
    ANSI92_INTERMEDIATE_SQL = 1,
    ANSI92_FULL_SQL = 2,
}

impl ::protobuf::ProtobufEnum for SupportedAnsi92SqlGrammarLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupportedAnsi92SqlGrammarLevel> {
        match value {
            0 => ::std::option::Option::Some(SupportedAnsi92SqlGrammarLevel::ANSI92_ENTRY_SQL),
            1 => ::std::option::Option::Some(SupportedAnsi92SqlGrammarLevel::ANSI92_INTERMEDIATE_SQL),
            2 => ::std::option::Option::Some(SupportedAnsi92SqlGrammarLevel::ANSI92_FULL_SQL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupportedAnsi92SqlGrammarLevel] = &[
            SupportedAnsi92SqlGrammarLevel::ANSI92_ENTRY_SQL,
            SupportedAnsi92SqlGrammarLevel::ANSI92_INTERMEDIATE_SQL,
            SupportedAnsi92SqlGrammarLevel::ANSI92_FULL_SQL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SupportedAnsi92SqlGrammarLevel>("SupportedAnsi92SqlGrammarLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SupportedAnsi92SqlGrammarLevel {
}

impl ::std::default::Default for SupportedAnsi92SqlGrammarLevel {
    fn default() -> Self {
        SupportedAnsi92SqlGrammarLevel::ANSI92_ENTRY_SQL
    }
}

impl ::protobuf::reflect::ProtobufValue for SupportedAnsi92SqlGrammarLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlOuterJoinsSupportLevel {
    SQL_JOINS_UNSUPPORTED = 0,
    SQL_LIMITED_OUTER_JOINS = 1,
    SQL_FULL_OUTER_JOINS = 2,
}

impl ::protobuf::ProtobufEnum for SqlOuterJoinsSupportLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlOuterJoinsSupportLevel> {
        match value {
            0 => ::std::option::Option::Some(SqlOuterJoinsSupportLevel::SQL_JOINS_UNSUPPORTED),
            1 => ::std::option::Option::Some(SqlOuterJoinsSupportLevel::SQL_LIMITED_OUTER_JOINS),
            2 => ::std::option::Option::Some(SqlOuterJoinsSupportLevel::SQL_FULL_OUTER_JOINS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlOuterJoinsSupportLevel] = &[
            SqlOuterJoinsSupportLevel::SQL_JOINS_UNSUPPORTED,
            SqlOuterJoinsSupportLevel::SQL_LIMITED_OUTER_JOINS,
            SqlOuterJoinsSupportLevel::SQL_FULL_OUTER_JOINS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlOuterJoinsSupportLevel>("SqlOuterJoinsSupportLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlOuterJoinsSupportLevel {
}

impl ::std::default::Default for SqlOuterJoinsSupportLevel {
    fn default() -> Self {
        SqlOuterJoinsSupportLevel::SQL_JOINS_UNSUPPORTED
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlOuterJoinsSupportLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedGroupBy {
    SQL_GROUP_BY_UNRELATED = 0,
    SQL_GROUP_BY_BEYOND_SELECT = 1,
}

impl ::protobuf::ProtobufEnum for SqlSupportedGroupBy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedGroupBy> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedGroupBy::SQL_GROUP_BY_UNRELATED),
            1 => ::std::option::Option::Some(SqlSupportedGroupBy::SQL_GROUP_BY_BEYOND_SELECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedGroupBy] = &[
            SqlSupportedGroupBy::SQL_GROUP_BY_UNRELATED,
            SqlSupportedGroupBy::SQL_GROUP_BY_BEYOND_SELECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedGroupBy>("SqlSupportedGroupBy", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedGroupBy {
}

impl ::std::default::Default for SqlSupportedGroupBy {
    fn default() -> Self {
        SqlSupportedGroupBy::SQL_GROUP_BY_UNRELATED
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedGroupBy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedElementActions {
    SQL_ELEMENT_IN_PROCEDURE_CALLS = 0,
    SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1,
    SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2,
}

impl ::protobuf::ProtobufEnum for SqlSupportedElementActions {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedElementActions> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedElementActions::SQL_ELEMENT_IN_PROCEDURE_CALLS),
            1 => ::std::option::Option::Some(SqlSupportedElementActions::SQL_ELEMENT_IN_INDEX_DEFINITIONS),
            2 => ::std::option::Option::Some(SqlSupportedElementActions::SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedElementActions] = &[
            SqlSupportedElementActions::SQL_ELEMENT_IN_PROCEDURE_CALLS,
            SqlSupportedElementActions::SQL_ELEMENT_IN_INDEX_DEFINITIONS,
            SqlSupportedElementActions::SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedElementActions>("SqlSupportedElementActions", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedElementActions {
}

impl ::std::default::Default for SqlSupportedElementActions {
    fn default() -> Self {
        SqlSupportedElementActions::SQL_ELEMENT_IN_PROCEDURE_CALLS
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedElementActions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedPositionedCommands {
    SQL_POSITIONED_DELETE = 0,
    SQL_POSITIONED_UPDATE = 1,
}

impl ::protobuf::ProtobufEnum for SqlSupportedPositionedCommands {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedPositionedCommands> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedPositionedCommands::SQL_POSITIONED_DELETE),
            1 => ::std::option::Option::Some(SqlSupportedPositionedCommands::SQL_POSITIONED_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedPositionedCommands] = &[
            SqlSupportedPositionedCommands::SQL_POSITIONED_DELETE,
            SqlSupportedPositionedCommands::SQL_POSITIONED_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedPositionedCommands>("SqlSupportedPositionedCommands", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedPositionedCommands {
}

impl ::std::default::Default for SqlSupportedPositionedCommands {
    fn default() -> Self {
        SqlSupportedPositionedCommands::SQL_POSITIONED_DELETE
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedPositionedCommands {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedSubqueries {
    SQL_SUBQUERIES_IN_COMPARISONS = 0,
    SQL_SUBQUERIES_IN_EXISTS = 1,
    SQL_SUBQUERIES_IN_INS = 2,
    SQL_SUBQUERIES_IN_QUANTIFIEDS = 3,
}

impl ::protobuf::ProtobufEnum for SqlSupportedSubqueries {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedSubqueries> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedSubqueries::SQL_SUBQUERIES_IN_COMPARISONS),
            1 => ::std::option::Option::Some(SqlSupportedSubqueries::SQL_SUBQUERIES_IN_EXISTS),
            2 => ::std::option::Option::Some(SqlSupportedSubqueries::SQL_SUBQUERIES_IN_INS),
            3 => ::std::option::Option::Some(SqlSupportedSubqueries::SQL_SUBQUERIES_IN_QUANTIFIEDS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedSubqueries] = &[
            SqlSupportedSubqueries::SQL_SUBQUERIES_IN_COMPARISONS,
            SqlSupportedSubqueries::SQL_SUBQUERIES_IN_EXISTS,
            SqlSupportedSubqueries::SQL_SUBQUERIES_IN_INS,
            SqlSupportedSubqueries::SQL_SUBQUERIES_IN_QUANTIFIEDS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedSubqueries>("SqlSupportedSubqueries", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedSubqueries {
}

impl ::std::default::Default for SqlSupportedSubqueries {
    fn default() -> Self {
        SqlSupportedSubqueries::SQL_SUBQUERIES_IN_COMPARISONS
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedSubqueries {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedUnions {
    SQL_UNION = 0,
    SQL_UNION_ALL = 1,
}

impl ::protobuf::ProtobufEnum for SqlSupportedUnions {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedUnions> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedUnions::SQL_UNION),
            1 => ::std::option::Option::Some(SqlSupportedUnions::SQL_UNION_ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedUnions] = &[
            SqlSupportedUnions::SQL_UNION,
            SqlSupportedUnions::SQL_UNION_ALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedUnions>("SqlSupportedUnions", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedUnions {
}

impl ::std::default::Default for SqlSupportedUnions {
    fn default() -> Self {
        SqlSupportedUnions::SQL_UNION
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedUnions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlTransactionIsolationLevel {
    SQL_TRANSACTION_NONE = 0,
    SQL_TRANSACTION_READ_UNCOMMITTED = 1,
    SQL_TRANSACTION_READ_COMMITTED = 2,
    SQL_TRANSACTION_REPEATABLE_READ = 3,
    SQL_TRANSACTION_SERIALIZABLE = 4,
}

impl ::protobuf::ProtobufEnum for SqlTransactionIsolationLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlTransactionIsolationLevel> {
        match value {
            0 => ::std::option::Option::Some(SqlTransactionIsolationLevel::SQL_TRANSACTION_NONE),
            1 => ::std::option::Option::Some(SqlTransactionIsolationLevel::SQL_TRANSACTION_READ_UNCOMMITTED),
            2 => ::std::option::Option::Some(SqlTransactionIsolationLevel::SQL_TRANSACTION_READ_COMMITTED),
            3 => ::std::option::Option::Some(SqlTransactionIsolationLevel::SQL_TRANSACTION_REPEATABLE_READ),
            4 => ::std::option::Option::Some(SqlTransactionIsolationLevel::SQL_TRANSACTION_SERIALIZABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlTransactionIsolationLevel] = &[
            SqlTransactionIsolationLevel::SQL_TRANSACTION_NONE,
            SqlTransactionIsolationLevel::SQL_TRANSACTION_READ_UNCOMMITTED,
            SqlTransactionIsolationLevel::SQL_TRANSACTION_READ_COMMITTED,
            SqlTransactionIsolationLevel::SQL_TRANSACTION_REPEATABLE_READ,
            SqlTransactionIsolationLevel::SQL_TRANSACTION_SERIALIZABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlTransactionIsolationLevel>("SqlTransactionIsolationLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlTransactionIsolationLevel {
}

impl ::std::default::Default for SqlTransactionIsolationLevel {
    fn default() -> Self {
        SqlTransactionIsolationLevel::SQL_TRANSACTION_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlTransactionIsolationLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedTransactions {
    SQL_TRANSACTION_UNSPECIFIED = 0,
    SQL_DATA_DEFINITION_TRANSACTIONS = 1,
    SQL_DATA_MANIPULATION_TRANSACTIONS = 2,
}

impl ::protobuf::ProtobufEnum for SqlSupportedTransactions {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedTransactions> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedTransactions::SQL_TRANSACTION_UNSPECIFIED),
            1 => ::std::option::Option::Some(SqlSupportedTransactions::SQL_DATA_DEFINITION_TRANSACTIONS),
            2 => ::std::option::Option::Some(SqlSupportedTransactions::SQL_DATA_MANIPULATION_TRANSACTIONS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedTransactions] = &[
            SqlSupportedTransactions::SQL_TRANSACTION_UNSPECIFIED,
            SqlSupportedTransactions::SQL_DATA_DEFINITION_TRANSACTIONS,
            SqlSupportedTransactions::SQL_DATA_MANIPULATION_TRANSACTIONS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedTransactions>("SqlSupportedTransactions", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedTransactions {
}

impl ::std::default::Default for SqlSupportedTransactions {
    fn default() -> Self {
        SqlSupportedTransactions::SQL_TRANSACTION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedTransactions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedResultSetType {
    SQL_RESULT_SET_TYPE_UNSPECIFIED = 0,
    SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1,
    SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2,
    SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3,
}

impl ::protobuf::ProtobufEnum for SqlSupportedResultSetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedResultSetType> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_FORWARD_ONLY),
            2 => ::std::option::Option::Some(SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE),
            3 => ::std::option::Option::Some(SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedResultSetType] = &[
            SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_UNSPECIFIED,
            SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_FORWARD_ONLY,
            SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE,
            SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedResultSetType>("SqlSupportedResultSetType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedResultSetType {
}

impl ::std::default::Default for SqlSupportedResultSetType {
    fn default() -> Self {
        SqlSupportedResultSetType::SQL_RESULT_SET_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedResultSetType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportedResultSetConcurrency {
    SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0,
    SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1,
    SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2,
}

impl ::protobuf::ProtobufEnum for SqlSupportedResultSetConcurrency {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportedResultSetConcurrency> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED),
            1 => ::std::option::Option::Some(SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_READ_ONLY),
            2 => ::std::option::Option::Some(SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_UPDATABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportedResultSetConcurrency] = &[
            SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED,
            SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_READ_ONLY,
            SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_UPDATABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportedResultSetConcurrency>("SqlSupportedResultSetConcurrency", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportedResultSetConcurrency {
}

impl ::std::default::Default for SqlSupportedResultSetConcurrency {
    fn default() -> Self {
        SqlSupportedResultSetConcurrency::SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportedResultSetConcurrency {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SqlSupportsConvert {
    SQL_CONVERT_BIGINT = 0,
    SQL_CONVERT_BINARY = 1,
    SQL_CONVERT_BIT = 2,
    SQL_CONVERT_CHAR = 3,
    SQL_CONVERT_DATE = 4,
    SQL_CONVERT_DECIMAL = 5,
    SQL_CONVERT_FLOAT = 6,
    SQL_CONVERT_INTEGER = 7,
    SQL_CONVERT_INTERVAL_DAY_TIME = 8,
    SQL_CONVERT_INTERVAL_YEAR_MONTH = 9,
    SQL_CONVERT_LONGVARBINARY = 10,
    SQL_CONVERT_LONGVARCHAR = 11,
    SQL_CONVERT_NUMERIC = 12,
    SQL_CONVERT_REAL = 13,
    SQL_CONVERT_SMALLINT = 14,
    SQL_CONVERT_TIME = 15,
    SQL_CONVERT_TIMESTAMP = 16,
    SQL_CONVERT_TINYINT = 17,
    SQL_CONVERT_VARBINARY = 18,
    SQL_CONVERT_VARCHAR = 19,
}

impl ::protobuf::ProtobufEnum for SqlSupportsConvert {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SqlSupportsConvert> {
        match value {
            0 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_BIGINT),
            1 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_BINARY),
            2 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_BIT),
            3 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_CHAR),
            4 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_DATE),
            5 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_DECIMAL),
            6 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_FLOAT),
            7 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_INTEGER),
            8 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_INTERVAL_DAY_TIME),
            9 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_INTERVAL_YEAR_MONTH),
            10 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_LONGVARBINARY),
            11 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_LONGVARCHAR),
            12 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_NUMERIC),
            13 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_REAL),
            14 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_SMALLINT),
            15 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_TIME),
            16 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_TIMESTAMP),
            17 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_TINYINT),
            18 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_VARBINARY),
            19 => ::std::option::Option::Some(SqlSupportsConvert::SQL_CONVERT_VARCHAR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SqlSupportsConvert] = &[
            SqlSupportsConvert::SQL_CONVERT_BIGINT,
            SqlSupportsConvert::SQL_CONVERT_BINARY,
            SqlSupportsConvert::SQL_CONVERT_BIT,
            SqlSupportsConvert::SQL_CONVERT_CHAR,
            SqlSupportsConvert::SQL_CONVERT_DATE,
            SqlSupportsConvert::SQL_CONVERT_DECIMAL,
            SqlSupportsConvert::SQL_CONVERT_FLOAT,
            SqlSupportsConvert::SQL_CONVERT_INTEGER,
            SqlSupportsConvert::SQL_CONVERT_INTERVAL_DAY_TIME,
            SqlSupportsConvert::SQL_CONVERT_INTERVAL_YEAR_MONTH,
            SqlSupportsConvert::SQL_CONVERT_LONGVARBINARY,
            SqlSupportsConvert::SQL_CONVERT_LONGVARCHAR,
            SqlSupportsConvert::SQL_CONVERT_NUMERIC,
            SqlSupportsConvert::SQL_CONVERT_REAL,
            SqlSupportsConvert::SQL_CONVERT_SMALLINT,
            SqlSupportsConvert::SQL_CONVERT_TIME,
            SqlSupportsConvert::SQL_CONVERT_TIMESTAMP,
            SqlSupportsConvert::SQL_CONVERT_TINYINT,
            SqlSupportsConvert::SQL_CONVERT_VARBINARY,
            SqlSupportsConvert::SQL_CONVERT_VARCHAR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SqlSupportsConvert>("SqlSupportsConvert", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SqlSupportsConvert {
}

impl ::std::default::Default for SqlSupportsConvert {
    fn default() -> Self {
        SqlSupportsConvert::SQL_CONVERT_BIGINT
    }
}

impl ::protobuf::reflect::ProtobufValue for SqlSupportsConvert {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdateDeleteRules {
    CASCADE = 0,
    RESTRICT = 1,
    SET_NULL = 2,
    NO_ACTION = 3,
    SET_DEFAULT = 4,
}

impl ::protobuf::ProtobufEnum for UpdateDeleteRules {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateDeleteRules> {
        match value {
            0 => ::std::option::Option::Some(UpdateDeleteRules::CASCADE),
            1 => ::std::option::Option::Some(UpdateDeleteRules::RESTRICT),
            2 => ::std::option::Option::Some(UpdateDeleteRules::SET_NULL),
            3 => ::std::option::Option::Some(UpdateDeleteRules::NO_ACTION),
            4 => ::std::option::Option::Some(UpdateDeleteRules::SET_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdateDeleteRules] = &[
            UpdateDeleteRules::CASCADE,
            UpdateDeleteRules::RESTRICT,
            UpdateDeleteRules::SET_NULL,
            UpdateDeleteRules::NO_ACTION,
            UpdateDeleteRules::SET_DEFAULT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UpdateDeleteRules>("UpdateDeleteRules", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UpdateDeleteRules {
}

impl ::std::default::Default for UpdateDeleteRules {
    fn default() -> Self {
        UpdateDeleteRules::CASCADE
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDeleteRules {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

/// Extension fields
pub mod exts {

    pub const experimental: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 1000, phantom: ::std::marker::PhantomData };
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fFlightSql.proto\x12\x19arrow.flight.protocol.sql\x1a\x20google/pro\
    tobuf/descriptor.proto\",\n\x11CommandGetSqlInfo\x12\x12\n\x04info\x18\
    \x01\x20\x03(\rR\x04info:\x03\xc0>\x01\"\x19\n\x12CommandGetCatalogs:\
    \x03\xc0>\x01\"\xa0\x01\n\x13CommandGetDbSchemas\x12\x1d\n\x07catalog\
    \x18\x01\x20\x01(\tH\0R\x07catalog\x88\x01\x01\x12<\n\x18db_schema_filte\
    r_pattern\x18\x02\x20\x01(\tH\x01R\x15dbSchemaFilterPattern\x88\x01\x01B\
    \n\n\x08_catalogB\x1b\n\x19_db_schema_filter_pattern:\x03\xc0>\x01\"\xc3\
    \x02\n\x10CommandGetTables\x12\x1d\n\x07catalog\x18\x01\x20\x01(\tH\0R\
    \x07catalog\x88\x01\x01\x12<\n\x18db_schema_filter_pattern\x18\x02\x20\
    \x01(\tH\x01R\x15dbSchemaFilterPattern\x88\x01\x01\x12>\n\x19table_name_\
    filter_pattern\x18\x03\x20\x01(\tH\x02R\x16tableNameFilterPattern\x88\
    \x01\x01\x12\x1f\n\x0btable_types\x18\x04\x20\x03(\tR\ntableTypes\x12%\n\
    \x0einclude_schema\x18\x05\x20\x01(\x08R\rincludeSchemaB\n\n\x08_catalog\
    B\x1b\n\x19_db_schema_filter_patternB\x1c\n\x1a_table_name_filter_patter\
    n:\x03\xc0>\x01\"\x1b\n\x14CommandGetTableTypes:\x03\xc0>\x01\"\x8d\x01\
    \n\x15CommandGetPrimaryKeys\x12\x1d\n\x07catalog\x18\x01\x20\x01(\tH\0R\
    \x07catalog\x88\x01\x01\x12\x20\n\tdb_schema\x18\x02\x20\x01(\tH\x01R\
    \x08dbSchema\x88\x01\x01\x12\x14\n\x05table\x18\x03\x20\x01(\tR\x05table\
    B\n\n\x08_catalogB\x0c\n\n_db_schema:\x03\xc0>\x01\"\x8e\x01\n\x16Comman\
    dGetExportedKeys\x12\x1d\n\x07catalog\x18\x01\x20\x01(\tH\0R\x07catalog\
    \x88\x01\x01\x12\x20\n\tdb_schema\x18\x02\x20\x01(\tH\x01R\x08dbSchema\
    \x88\x01\x01\x12\x14\n\x05table\x18\x03\x20\x01(\tR\x05tableB\n\n\x08_ca\
    talogB\x0c\n\n_db_schema:\x03\xc0>\x01\"\x8e\x01\n\x16CommandGetImported\
    Keys\x12\x1d\n\x07catalog\x18\x01\x20\x01(\tH\0R\x07catalog\x88\x01\x01\
    \x12\x20\n\tdb_schema\x18\x02\x20\x01(\tH\x01R\x08dbSchema\x88\x01\x01\
    \x12\x14\n\x05table\x18\x03\x20\x01(\tR\x05tableB\n\n\x08_catalogB\x0c\n\
    \n_db_schema:\x03\xc0>\x01\"\xab\x02\n\x18CommandGetCrossReference\x12\"\
    \n\npk_catalog\x18\x01\x20\x01(\tH\0R\tpkCatalog\x88\x01\x01\x12%\n\x0cp\
    k_db_schema\x18\x02\x20\x01(\tH\x01R\npkDbSchema\x88\x01\x01\x12\x19\n\
    \x08pk_table\x18\x03\x20\x01(\tR\x07pkTable\x12\"\n\nfk_catalog\x18\x04\
    \x20\x01(\tH\x02R\tfkCatalog\x88\x01\x01\x12%\n\x0cfk_db_schema\x18\x05\
    \x20\x01(\tH\x03R\nfkDbSchema\x88\x01\x01\x12\x19\n\x08fk_table\x18\x06\
    \x20\x01(\tR\x07fkTableB\r\n\x0b_pk_catalogB\x0f\n\r_pk_db_schemaB\r\n\
    \x0b_fk_catalogB\x0f\n\r_fk_db_schema:\x03\xc0>\x01\"A\n$ActionCreatePre\
    paredStatementRequest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query:\
    \x03\xc0>\x01\"\xb8\x01\n#ActionCreatePreparedStatementResult\x12:\n\x19\
    prepared_statement_handle\x18\x01\x20\x01(\x0cR\x17preparedStatementHand\
    le\x12%\n\x0edataset_schema\x18\x02\x20\x01(\x0cR\rdatasetSchema\x12)\n\
    \x10parameter_schema\x18\x03\x20\x01(\x0cR\x0fparameterSchema:\x03\xc0>\
    \x01\"f\n#ActionClosePreparedStatementRequest\x12:\n\x19prepared_stateme\
    nt_handle\x18\x01\x20\x01(\x0cR\x17preparedStatementHandle:\x03\xc0>\x01\
    \"2\n\x15CommandStatementQuery\x12\x14\n\x05query\x18\x01\x20\x01(\tR\
    \x05query:\x03\xc0>\x01\"F\n\x14TicketStatementQuery\x12)\n\x10statement\
    _handle\x18\x01\x20\x01(\x0cR\x0fstatementHandle:\x03\xc0>\x01\"`\n\x1dC\
    ommandPreparedStatementQuery\x12:\n\x19prepared_statement_handle\x18\x01\
    \x20\x01(\x0cR\x17preparedStatementHandle:\x03\xc0>\x01\"3\n\x16CommandS\
    tatementUpdate\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query:\x03\xc0>\
    \x01\"a\n\x1eCommandPreparedStatementUpdate\x12:\n\x19prepared_statement\
    _handle\x18\x01\x20\x01(\x0cR\x17preparedStatementHandle:\x03\xc0>\x01\"\
    ;\n\x11DoPutUpdateResult\x12!\n\x0crecord_count\x18\x01\x20\x01(\x03R\
    \x0brecordCount:\x03\xc0>\x01*\x8c\x16\n\x07SqlInfo\x12\x1a\n\x16FLIGHT_\
    SQL_SERVER_NAME\x10\0\x12\x1d\n\x19FLIGHT_SQL_SERVER_VERSION\x10\x01\x12\
    #\n\x1fFLIGHT_SQL_SERVER_ARROW_VERSION\x10\x02\x12\x1f\n\x1bFLIGHT_SQL_S\
    ERVER_READ_ONLY\x10\x03\x12\x14\n\x0fSQL_DDL_CATALOG\x10\xf4\x03\x12\x13\
    \n\x0eSQL_DDL_SCHEMA\x10\xf5\x03\x12\x12\n\rSQL_DDL_TABLE\x10\xf6\x03\
    \x12\x18\n\x13SQL_IDENTIFIER_CASE\x10\xf7\x03\x12\x1e\n\x19SQL_IDENTIFIE\
    R_QUOTE_CHAR\x10\xf8\x03\x12\x1f\n\x1aSQL_QUOTED_IDENTIFIER_CASE\x10\xf9\
    \x03\x12\"\n\x1dSQL_ALL_TABLES_ARE_SELECTABLE\x10\xfa\x03\x12\x16\n\x11S\
    QL_NULL_ORDERING\x10\xfb\x03\x12\x11\n\x0cSQL_KEYWORDS\x10\xfc\x03\x12\
    \x1a\n\x15SQL_NUMERIC_FUNCTIONS\x10\xfd\x03\x12\x19\n\x14SQL_STRING_FUNC\
    TIONS\x10\xfe\x03\x12\x19\n\x14SQL_SYSTEM_FUNCTIONS\x10\xff\x03\x12\x1b\
    \n\x16SQL_DATETIME_FUNCTIONS\x10\x80\x04\x12\x1d\n\x18SQL_SEARCH_STRING_\
    ESCAPE\x10\x81\x04\x12\x1e\n\x19SQL_EXTRA_NAME_CHARACTERS\x10\x82\x04\
    \x12!\n\x1cSQL_SUPPORTS_COLUMN_ALIASING\x10\x83\x04\x12\x1f\n\x1aSQL_NUL\
    L_PLUS_NULL_IS_NULL\x10\x84\x04\x12\x19\n\x14SQL_SUPPORTS_CONVERT\x10\
    \x85\x04\x12)\n$SQL_SUPPORTS_TABLE_CORRELATION_NAMES\x10\x86\x04\x123\n.\
    SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES\x10\x87\x04\x12)\n$SQL_SU\
    PPORTS_EXPRESSIONS_IN_ORDER_BY\x10\x88\x04\x12$\n\x1fSQL_SUPPORTS_ORDER_\
    BY_UNRELATED\x10\x89\x04\x12\x1b\n\x16SQL_SUPPORTED_GROUP_BY\x10\x8a\x04\
    \x12$\n\x1fSQL_SUPPORTS_LIKE_ESCAPE_CLAUSE\x10\x8b\x04\x12&\n!SQL_SUPPOR\
    TS_NON_NULLABLE_COLUMNS\x10\x8c\x04\x12\x1a\n\x15SQL_SUPPORTED_GRAMMAR\
    \x10\x8d\x04\x12\x1f\n\x1aSQL_ANSI92_SUPPORTED_LEVEL\x10\x8e\x04\x120\n+\
    SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY\x10\x8f\x04\x12\"\n\x1dSQL_O\
    UTER_JOINS_SUPPORT_LEVEL\x10\x90\x04\x12\x14\n\x0fSQL_SCHEMA_TERM\x10\
    \x91\x04\x12\x17\n\x12SQL_PROCEDURE_TERM\x10\x92\x04\x12\x15\n\x10SQL_CA\
    TALOG_TERM\x10\x93\x04\x12\x19\n\x14SQL_CATALOG_AT_START\x10\x94\x04\x12\
    \"\n\x1dSQL_SCHEMAS_SUPPORTED_ACTIONS\x10\x95\x04\x12#\n\x1eSQL_CATALOGS\
    _SUPPORTED_ACTIONS\x10\x96\x04\x12&\n!SQL_SUPPORTED_POSITIONED_COMMANDS\
    \x10\x97\x04\x12$\n\x1fSQL_SELECT_FOR_UPDATE_SUPPORTED\x10\x98\x04\x12$\
    \n\x1fSQL_STORED_PROCEDURES_SUPPORTED\x10\x99\x04\x12\x1d\n\x18SQL_SUPPO\
    RTED_SUBQUERIES\x10\x9a\x04\x12(\n#SQL_CORRELATED_SUBQUERIES_SUPPORTED\
    \x10\x9b\x04\x12\x19\n\x14SQL_SUPPORTED_UNIONS\x10\x9c\x04\x12\"\n\x1dSQ\
    L_MAX_BINARY_LITERAL_LENGTH\x10\x9d\x04\x12\x20\n\x1bSQL_MAX_CHAR_LITERA\
    L_LENGTH\x10\x9e\x04\x12\x1f\n\x1aSQL_MAX_COLUMN_NAME_LENGTH\x10\x9f\x04\
    \x12\x20\n\x1bSQL_MAX_COLUMNS_IN_GROUP_BY\x10\xa0\x04\x12\x1d\n\x18SQL_M\
    AX_COLUMNS_IN_INDEX\x10\xa1\x04\x12\x20\n\x1bSQL_MAX_COLUMNS_IN_ORDER_BY\
    \x10\xa2\x04\x12\x1e\n\x19SQL_MAX_COLUMNS_IN_SELECT\x10\xa3\x04\x12\x1d\
    \n\x18SQL_MAX_COLUMNS_IN_TABLE\x10\xa4\x04\x12\x18\n\x13SQL_MAX_CONNECTI\
    ONS\x10\xa5\x04\x12\x1f\n\x1aSQL_MAX_CURSOR_NAME_LENGTH\x10\xa6\x04\x12\
    \x19\n\x14SQL_MAX_INDEX_LENGTH\x10\xa7\x04\x12\x1e\n\x19SQL_DB_SCHEMA_NA\
    ME_LENGTH\x10\xa8\x04\x12\"\n\x1dSQL_MAX_PROCEDURE_NAME_LENGTH\x10\xa9\
    \x04\x12\x20\n\x1bSQL_MAX_CATALOG_NAME_LENGTH\x10\xaa\x04\x12\x15\n\x10S\
    QL_MAX_ROW_SIZE\x10\xab\x04\x12$\n\x1fSQL_MAX_ROW_SIZE_INCLUDES_BLOBS\
    \x10\xac\x04\x12\x1d\n\x18SQL_MAX_STATEMENT_LENGTH\x10\xad\x04\x12\x17\n\
    \x12SQL_MAX_STATEMENTS\x10\xae\x04\x12\x1e\n\x19SQL_MAX_TABLE_NAME_LENGT\
    H\x10\xaf\x04\x12\x1d\n\x18SQL_MAX_TABLES_IN_SELECT\x10\xb0\x04\x12\x1c\
    \n\x17SQL_MAX_USERNAME_LENGTH\x10\xb1\x04\x12&\n!SQL_DEFAULT_TRANSACTION\
    _ISOLATION\x10\xb2\x04\x12\x1f\n\x1aSQL_TRANSACTIONS_SUPPORTED\x10\xb3\
    \x04\x120\n+SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS\x10\xb4\x04\x122\
    \n-SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT\x10\xb5\x04\x121\n,SQL_\
    DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED\x10\xb6\x04\x12#\n\x1eSQL_SUPPO\
    RTED_RESULT_SET_TYPES\x10\xb7\x04\x12;\n6SQL_SUPPORTED_CONCURRENCIES_FOR\
    _RESULT_SET_UNSPECIFIED\x10\xb8\x04\x12<\n7SQL_SUPPORTED_CONCURRENCIES_F\
    OR_RESULT_SET_FORWARD_ONLY\x10\xb9\x04\x12@\n;SQL_SUPPORTED_CONCURRENCIE\
    S_FOR_RESULT_SET_SCROLL_SENSITIVE\x10\xba\x04\x12B\n=SQL_SUPPORTED_CONCU\
    RRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE\x10\xbb\x04\x12\x20\n\x1bSQL_\
    BATCH_UPDATES_SUPPORTED\x10\xbc\x04\x12\x1d\n\x18SQL_SAVEPOINTS_SUPPORTE\
    D\x10\xbd\x04\x12#\n\x1eSQL_NAMED_PARAMETERS_SUPPORTED\x10\xbe\x04\x12\
    \x1d\n\x18SQL_LOCATORS_UPDATE_COPY\x10\xbf\x04\x125\n0SQL_STORED_FUNCTIO\
    NS_USING_CALL_SYNTAX_SUPPORTED\x10\xc0\x04*\xb2\x01\n\x1bSqlSupportedCas\
    eSensitivity\x12\x20\n\x1cSQL_CASE_SENSITIVITY_UNKNOWN\x10\0\x12)\n%SQL_\
    CASE_SENSITIVITY_CASE_INSENSITIVE\x10\x01\x12\"\n\x1eSQL_CASE_SENSITIVIT\
    Y_UPPERCASE\x10\x02\x12\"\n\x1eSQL_CASE_SENSITIVITY_LOWERCASE\x10\x03*\
    \x82\x01\n\x0fSqlNullOrdering\x12\x19\n\x15SQL_NULLS_SORTED_HIGH\x10\0\
    \x12\x18\n\x14SQL_NULLS_SORTED_LOW\x10\x01\x12\x1d\n\x19SQL_NULLS_SORTED\
    _AT_START\x10\x02\x12\x1b\n\x17SQL_NULLS_SORTED_AT_END\x10\x03*^\n\x13Su\
    pportedSqlGrammar\x12\x17\n\x13SQL_MINIMUM_GRAMMAR\x10\0\x12\x14\n\x10SQ\
    L_CORE_GRAMMAR\x10\x01\x12\x18\n\x14SQL_EXTENDED_GRAMMAR\x10\x02*h\n\x1e\
    SupportedAnsi92SqlGrammarLevel\x12\x14\n\x10ANSI92_ENTRY_SQL\x10\0\x12\
    \x1b\n\x17ANSI92_INTERMEDIATE_SQL\x10\x01\x12\x13\n\x0fANSI92_FULL_SQL\
    \x10\x02*m\n\x19SqlOuterJoinsSupportLevel\x12\x19\n\x15SQL_JOINS_UNSUPPO\
    RTED\x10\0\x12\x1b\n\x17SQL_LIMITED_OUTER_JOINS\x10\x01\x12\x18\n\x14SQL\
    _FULL_OUTER_JOINS\x10\x02*Q\n\x13SqlSupportedGroupBy\x12\x1a\n\x16SQL_GR\
    OUP_BY_UNRELATED\x10\0\x12\x1e\n\x1aSQL_GROUP_BY_BEYOND_SELECT\x10\x01*\
    \x90\x01\n\x1aSqlSupportedElementActions\x12\"\n\x1eSQL_ELEMENT_IN_PROCE\
    DURE_CALLS\x10\0\x12$\n\x20SQL_ELEMENT_IN_INDEX_DEFINITIONS\x10\x01\x12(\
    \n$SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS\x10\x02*V\n\x1eSqlSupportedPosit\
    ionedCommands\x12\x19\n\x15SQL_POSITIONED_DELETE\x10\0\x12\x19\n\x15SQL_\
    POSITIONED_UPDATE\x10\x01*\x97\x01\n\x16SqlSupportedSubqueries\x12!\n\
    \x1dSQL_SUBQUERIES_IN_COMPARISONS\x10\0\x12\x1c\n\x18SQL_SUBQUERIES_IN_E\
    XISTS\x10\x01\x12\x19\n\x15SQL_SUBQUERIES_IN_INS\x10\x02\x12!\n\x1dSQL_S\
    UBQUERIES_IN_QUANTIFIEDS\x10\x03*6\n\x12SqlSupportedUnions\x12\r\n\tSQL_\
    UNION\x10\0\x12\x11\n\rSQL_UNION_ALL\x10\x01*\xc9\x01\n\x1cSqlTransactio\
    nIsolationLevel\x12\x18\n\x14SQL_TRANSACTION_NONE\x10\0\x12$\n\x20SQL_TR\
    ANSACTION_READ_UNCOMMITTED\x10\x01\x12\"\n\x1eSQL_TRANSACTION_READ_COMMI\
    TTED\x10\x02\x12#\n\x1fSQL_TRANSACTION_REPEATABLE_READ\x10\x03\x12\x20\n\
    \x1cSQL_TRANSACTION_SERIALIZABLE\x10\x04*\x89\x01\n\x18SqlSupportedTrans\
    actions\x12\x1f\n\x1bSQL_TRANSACTION_UNSPECIFIED\x10\0\x12$\n\x20SQL_DAT\
    A_DEFINITION_TRANSACTIONS\x10\x01\x12&\n\"SQL_DATA_MANIPULATION_TRANSACT\
    IONS\x10\x02*\xbc\x01\n\x19SqlSupportedResultSetType\x12#\n\x1fSQL_RESUL\
    T_SET_TYPE_UNSPECIFIED\x10\0\x12$\n\x20SQL_RESULT_SET_TYPE_FORWARD_ONLY\
    \x10\x01\x12*\n&SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE\x10\x02\x12(\n$SQ\
    L_RESULT_SET_TYPE_SCROLL_SENSITIVE\x10\x03*\xa2\x01\n\x20SqlSupportedRes\
    ultSetConcurrency\x12*\n&SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED\x10\0\
    \x12(\n$SQL_RESULT_SET_CONCURRENCY_READ_ONLY\x10\x01\x12(\n$SQL_RESULT_S\
    ET_CONCURRENCY_UPDATABLE\x10\x02*\x99\x04\n\x12SqlSupportsConvert\x12\
    \x16\n\x12SQL_CONVERT_BIGINT\x10\0\x12\x16\n\x12SQL_CONVERT_BINARY\x10\
    \x01\x12\x13\n\x0fSQL_CONVERT_BIT\x10\x02\x12\x14\n\x10SQL_CONVERT_CHAR\
    \x10\x03\x12\x14\n\x10SQL_CONVERT_DATE\x10\x04\x12\x17\n\x13SQL_CONVERT_\
    DECIMAL\x10\x05\x12\x15\n\x11SQL_CONVERT_FLOAT\x10\x06\x12\x17\n\x13SQL_\
    CONVERT_INTEGER\x10\x07\x12!\n\x1dSQL_CONVERT_INTERVAL_DAY_TIME\x10\x08\
    \x12#\n\x1fSQL_CONVERT_INTERVAL_YEAR_MONTH\x10\t\x12\x1d\n\x19SQL_CONVER\
    T_LONGVARBINARY\x10\n\x12\x1b\n\x17SQL_CONVERT_LONGVARCHAR\x10\x0b\x12\
    \x17\n\x13SQL_CONVERT_NUMERIC\x10\x0c\x12\x14\n\x10SQL_CONVERT_REAL\x10\
    \r\x12\x18\n\x14SQL_CONVERT_SMALLINT\x10\x0e\x12\x14\n\x10SQL_CONVERT_TI\
    ME\x10\x0f\x12\x19\n\x15SQL_CONVERT_TIMESTAMP\x10\x10\x12\x17\n\x13SQL_C\
    ONVERT_TINYINT\x10\x11\x12\x19\n\x15SQL_CONVERT_VARBINARY\x10\x12\x12\
    \x17\n\x13SQL_CONVERT_VARCHAR\x10\x13*\\\n\x11UpdateDeleteRules\x12\x0b\
    \n\x07CASCADE\x10\0\x12\x0c\n\x08RESTRICT\x10\x01\x12\x0c\n\x08SET_NULL\
    \x10\x02\x12\r\n\tNO_ACTION\x10\x03\x12\x0f\n\x0bSET_DEFAULT\x10\x04:D\n\
    \x0cexperimental\x18\xe8\x07\x20\x01(\x08\x12\x1f.google.protobuf.Messag\
    eOptionsR\x0cexperimentalB\"\n\x20org.apache.arrow.flight.sql.implb\x06p\
    roto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}

}